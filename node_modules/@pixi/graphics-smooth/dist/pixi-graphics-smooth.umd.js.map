{"version":3,"file":"pixi-graphics-smooth.umd.js","sources":["../src/core/BatchDrawCall.ts","../src/core/BatchPart.ts","../src/core/FillStyle.ts","../src/core/LineStyle.ts","../src/core/BuildData.ts","../src/core/const.ts","../src/core/SegmentPacker.ts","../src/core/SmoothGraphicsData.ts","../src/shapes/CircleBuilder.ts","../src/shapes/RectangleBuilder.ts","../src/shapes/RoundedRectangleBuilder.ts","../src/shapes/PolyBuilder.ts","../src/shapes/index.ts","../src/SmoothGraphicsGeometry.ts","../src/SmoothShader.ts","../src/settings.ts","../src/SmoothGraphics.ts","../src/DashLineShader.ts"],"sourcesContent":["import { Matrix } from '@pixi/math';\r\nimport { BaseTexture, BatchTextureArray, Shader, Texture } from '@pixi/core';\r\nimport { BLEND_MODES } from '@pixi/constants';\r\n\r\nexport interface IGraphicsBatchSettings {\r\n    maxStyles: number;\r\n    maxTextures: number;\r\n    pixelLine: number;\r\n}\r\n\r\nexport function matrixEquals(th: Matrix, matrix: Matrix, eps = 1e-3)\r\n{\r\n    return this === matrix || Math.abs(th.a - matrix.a) < eps\r\n        && Math.abs(th.b - matrix.b) < eps\r\n        && Math.abs(th.c - matrix.c) < eps\r\n        && Math.abs(th.d - matrix.d) < eps\r\n        && Math.abs(th.tx - matrix.tx) < eps\r\n        && Math.abs(th.ty - matrix.ty) < eps;\r\n}\r\n\r\nexport class BatchStyleArray\r\n{\r\n    public textureIds: number[];\r\n    public matrices: Matrix[];\r\n    public lines: number[];\r\n    public count: number;\r\n\r\n    constructor()\r\n    {\r\n        this.textureIds = [];\r\n        this.matrices = [];\r\n        this.lines = [];\r\n        this.count = 0;\r\n        // TODO: mapCoord for atlas cases\r\n        // TODO: gradients?\r\n    }\r\n\r\n    clear(): void\r\n    {\r\n        for (let i = 0; i < this.count; i++)\r\n        {\r\n            this.textureIds[i] = null;\r\n            this.matrices[i] = null;\r\n        }\r\n        this.count = 0;\r\n    }\r\n\r\n    add(textureId: number, matrix: Matrix,\r\n        lineWidth: number, lineAlignment: number, lineScaleMode: number,\r\n        settings: IGraphicsBatchSettings): number\r\n    {\r\n        const { textureIds, matrices, lines, count } = this;\r\n\r\n        textureId = (textureId * 4) + lineScaleMode;\r\n        for (let i = 0; i < count; i++)\r\n        {\r\n            if (lines[i * 2] === lineWidth && lines[(i * 2) + 1] === lineAlignment\r\n                && textureIds[i] === textureId && (matrixEquals(matrices[i], matrix)))\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        if (count >= settings.maxStyles)\r\n        {\r\n            return -1;\r\n        }\r\n        textureIds[count] = textureId;\r\n        matrices[count] = matrix;\r\n        lines[count * 2] = lineWidth;\r\n        lines[(count * 2) + 1] = lineAlignment;\r\n        this.count++;\r\n\r\n        return count;\r\n    }\r\n}\r\n\r\nexport class BatchDrawCall\r\n{\r\n    texArray: BatchTextureArray;\r\n    styleArray: BatchStyleArray;\r\n    blend: BLEND_MODES;\r\n    start: number;\r\n    size: number;\r\n    data: any;\r\n    shader: Shader;\r\n    TICK: number;\r\n    settings: IGraphicsBatchSettings;\r\n\r\n    constructor()\r\n    {\r\n        this.texArray = new BatchTextureArray();\r\n        this.styleArray = new BatchStyleArray();\r\n        this.shader = null;\r\n        this.blend = BLEND_MODES.NORMAL;\r\n\r\n        this.start = 0;\r\n        this.size = 0;\r\n        this.TICK = 0; // for filling textures\r\n        this.settings = null;\r\n        /**\r\n         * data for uniforms or custom webgl state\r\n         * @member {object}\r\n         */\r\n        this.data = null;\r\n    }\r\n\r\n    clear()\r\n    {\r\n        this.texArray.clear();\r\n        this.styleArray.clear();\r\n        this.settings = null;\r\n        this.data = null;\r\n        this.shader = null;\r\n    }\r\n\r\n    begin(settings: IGraphicsBatchSettings, shader: Shader)\r\n    {\r\n        this.TICK = ++BaseTexture._globalBatch;\r\n        this.settings = settings;\r\n        this.shader = shader;\r\n        // start and size calculated outside\r\n        this.start = 0;\r\n        this.size = 0;\r\n        this.data = null;\r\n        if (shader && (shader as any).settings)\r\n        {\r\n            this.settings = (shader as any).settings;\r\n        }\r\n    }\r\n\r\n    check(shader: Shader): boolean\r\n    {\r\n        if (this.size === 0)\r\n        {\r\n            this.shader = shader;\r\n\r\n            return true;\r\n        }\r\n\r\n        return (this.shader === shader);\r\n    }\r\n\r\n    add(texture: Texture, matrix: Matrix, lineWidth: number,\r\n        lineAlignment: number, lineScaleMode: number): number\r\n    {\r\n        const { texArray, TICK, styleArray, settings } = this;\r\n        const { baseTexture } = texture;\r\n        // check tex\r\n\r\n        if (baseTexture._batchEnabled !== TICK && texArray.count === settings.maxTextures)\r\n        {\r\n            return -1;\r\n        }\r\n        const loc = baseTexture._batchEnabled !== TICK ? texArray.count : baseTexture._batchLocation;\r\n        // check and add style\r\n        // add1 -> add2 only works in chain, not when there are several adds inside\r\n        const res = styleArray.add(loc, matrix || Matrix.IDENTITY,\r\n            lineWidth, lineAlignment, lineScaleMode, settings);\r\n\r\n        if (res >= 0)\r\n        {\r\n            // SUCCESS here\r\n            // add tex\r\n            if (baseTexture._batchEnabled !== TICK)\r\n            {\r\n                baseTexture._batchEnabled = TICK;\r\n                baseTexture._batchLocation = texArray.count;\r\n                texArray.elements[texArray.count++] = baseTexture;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n","import { LineStyle } from './LineStyle';\r\nimport { FillStyle } from './FillStyle';\r\n\r\nexport class BatchPart\r\n{\r\n    public style: LineStyle | FillStyle;\r\n    public start: number;\r\n    public size: number;\r\n    public jointEnd: number;\r\n    public attribStart: number;\r\n    public attribSize: number;\r\n    public styleId: number;\r\n    public rgba: number;\r\n\r\n    constructor()\r\n    {\r\n        this.reset();\r\n    }\r\n\r\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\r\n    {\r\n        this.reset();\r\n        this.style = style;\r\n        this.start = startIndex;\r\n        this.attribStart = attribStart;\r\n        this.jointEnd = 0;\r\n    }\r\n\r\n    public end(endIndex: number, endAttrib: number): void\r\n    {\r\n        this.attribSize = endAttrib - this.attribStart;\r\n        this.size = endIndex - this.start;\r\n    }\r\n\r\n    public reset(): void\r\n    {\r\n        this.style = null;\r\n        this.size = 0;\r\n        this.start = 0;\r\n        this.attribStart = 0;\r\n        this.attribSize = 0;\r\n        this.styleId = -1;\r\n        this.rgba = 0;\r\n        this.jointEnd = 0;\r\n    }\r\n}\r\n","import { Shader, Texture } from '@pixi/core';\r\nimport type { Matrix } from '@pixi/math';\r\n\r\nexport class FillStyle\r\n{\r\n    constructor()\r\n    {\r\n        this.reset();\r\n    }\r\n\r\n    color: number;\r\n    alpha: number;\r\n    texture: Texture;\r\n    matrix: Matrix;\r\n    matrixTex: Matrix;\r\n    shader: Shader;\r\n    visible: boolean;\r\n    smooth: boolean;\r\n\r\n    toJSON()\r\n    {\r\n        return this.copyTo({});\r\n    }\r\n\r\n    clone(): FillStyle\r\n    {\r\n        return this.copyTo(new FillStyle());\r\n    }\r\n\r\n    copyTo(obj: any): any\r\n    {\r\n        obj.color = this.color;\r\n        obj.alpha = this.alpha;\r\n        obj.texture = this.texture;\r\n        obj.matrix = this.matrix;\r\n        obj.shader = this.shader;\r\n        obj.visible = this.visible;\r\n        obj.smooth = this.smooth;\r\n        obj.matrixTex = null;\r\n\r\n        return obj;\r\n    }\r\n\r\n    packLineScale()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    reset()\r\n    {\r\n        this.color = 0xFFFFFF;\r\n\r\n        this.alpha = 1;\r\n\r\n        this.texture = Texture.WHITE;\r\n\r\n        this.matrix = null;\r\n\r\n        this.shader = null;\r\n\r\n        this.visible = false;\r\n\r\n        this.smooth = false;\r\n\r\n        this.matrixTex = null;\r\n    }\r\n\r\n    destroy()\r\n    {\r\n        this.texture = null;\r\n        this.matrix = null;\r\n        this.matrixTex = null;\r\n    }\r\n\r\n    getTextureMatrix()\r\n    {\r\n        const tex = this.texture;\r\n\r\n        if (!this.matrix)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        if (tex.frame.width === tex.baseTexture.width\r\n            && tex.frame.height === tex.baseTexture.height)\r\n        {\r\n            return this.matrix;\r\n        }\r\n\r\n        if (!this.matrixTex)\r\n        {\r\n            this.matrixTex = this.matrix.clone();\r\n        }\r\n        else\r\n        {\r\n            this.matrixTex.copyFrom(this.matrix);\r\n        }\r\n        this.matrixTex.translate(Number(tex.frame.x), Number(tex.frame.y));\r\n\r\n        return this.matrixTex;\r\n    }\r\n}\r\n","import { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\r\nimport { FillStyle } from './FillStyle';\r\n\r\nexport enum LINE_SCALE_MODE {\r\n    NONE = 'none',\r\n    NORMAL = 'normal',\r\n    HORIZONTAL = 'horizontal',\r\n    VERTICAL = 'vertical',\r\n}\r\n\r\nexport class LineStyle extends FillStyle\r\n{\r\n    width: number;\r\n    alignment: number;\r\n\r\n    cap: LINE_CAP;\r\n    join: LINE_JOIN;\r\n    miterLimit: number;\r\n    scaleMode: LINE_SCALE_MODE;\r\n\r\n    clone(): LineStyle\r\n    {\r\n        return this.copyTo(new LineStyle());\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    copyTo(obj: any): LineStyle\r\n    {\r\n        obj.color = this.color;\r\n        obj.alpha = this.alpha;\r\n        obj.texture = this.texture;\r\n        obj.matrix = this.matrix;\r\n        obj.shader = this.shader;\r\n        obj.visible = this.visible;\r\n        obj.width = this.width;\r\n        obj.alignment = this.alignment;\r\n        obj.cap = this.cap;\r\n        obj.join = this.join;\r\n        obj.miterLimit = this.miterLimit;\r\n        obj.scaleMode = this.scaleMode;\r\n\r\n        return obj;\r\n    }\r\n\r\n    /**\r\n     * returns width multiplied by scaleMode\r\n     */\r\n    packLineScale(): number\r\n    {\r\n        switch (this.scaleMode)\r\n        {\r\n            case LINE_SCALE_MODE.NORMAL: return 1;\r\n            case LINE_SCALE_MODE.HORIZONTAL: return 2;\r\n            case LINE_SCALE_MODE.VERTICAL: return 3;\r\n            default: return 0;\r\n        }\r\n    }\r\n\r\n    reset(): void\r\n    {\r\n        super.reset();\r\n\r\n        this.smooth = true;\r\n\r\n        this.color = 0x0;\r\n\r\n        this.width = 0;\r\n\r\n        this.alignment = 0.5;\r\n\r\n        this.cap = LINE_CAP.BUTT;\r\n        this.join = LINE_JOIN.MITER;\r\n        this.miterLimit = 10;\r\n        this.scaleMode = LINE_SCALE_MODE.NORMAL;\r\n    }\r\n}\r\n","export class BuildData\r\n{\r\n    verts: Array<number> = [];\r\n    joints: Array<number> = [];\r\n    vertexSize = 0;\r\n    indexSize = 0;\r\n    closePointEps = 1e-4;\r\n\r\n    clear()\r\n    {\r\n        this.verts.length = 0;\r\n        this.joints.length = 0;\r\n        this.vertexSize = 0;\r\n        this.indexSize = 0;\r\n    }\r\n\r\n    destroy()\r\n    {\r\n        this.verts.length = 0;\r\n        this.joints.length = 0;\r\n    }\r\n}\r\n","export enum JOINT_TYPE {\r\n    NONE = 0,\r\n    FILL = 1,\r\n    JOINT_BEVEL = 4,\r\n    JOINT_MITER = 8,\r\n    JOINT_ROUND = 12,\r\n    JOINT_CAP_BUTT = 16,\r\n    JOINT_CAP_SQUARE = 18,\r\n    JOINT_CAP_ROUND = 20,\r\n    FILL_EXPAND = 24,\r\n    CAP_BUTT = 1 << 5,\r\n    CAP_SQUARE = 2 << 5,\r\n    CAP_ROUND = 3 << 5,\r\n    CAP_BUTT2 = 4 << 5,\r\n}\r\n","import { BuildData } from './BuildData';\r\nimport { JOINT_TYPE } from './const';\r\n\r\nexport class SegmentPacker\r\n{\r\n    static vertsByJoint: Array<number> = [];\r\n\r\n    strideFloats = 12;\r\n\r\n    updateBufferSize(jointStart: number, jointLen: number, triangles: number, target: BuildData): void\r\n    {\r\n        const { joints } = target;\r\n        let foundTriangle = false;\r\n\r\n        let vertexSize = 0;\r\n        let indexSize = 0;\r\n\r\n        for (let i = jointStart; i < jointStart + jointLen; i++)\r\n        {\r\n            const prevCap = joints[i] & ~31;\r\n            const joint = joints[i] & 31;\r\n\r\n            if (joint === JOINT_TYPE.FILL)\r\n            {\r\n                foundTriangle = true;\r\n                vertexSize++;\r\n                continue;\r\n            }\r\n\r\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\r\n            {\r\n                vertexSize += 3;\r\n                indexSize += 3;\r\n                continue;\r\n            }\r\n\r\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\r\n\r\n            if (vs >= 4)\r\n            {\r\n                vertexSize += vs;\r\n                indexSize += 6 + (3 * Math.max(vs - 6, 0));\r\n            }\r\n        }\r\n        if (foundTriangle)\r\n        {\r\n            indexSize += triangles;\r\n        }\r\n\r\n        target.vertexSize += vertexSize;\r\n        target.indexSize += indexSize;\r\n    }\r\n\r\n    bufferPos = 0;\r\n    indexPos = 0;\r\n    bufFloat: Float32Array;\r\n    bufUint: Uint32Array;\r\n    indices: Uint16Array;\r\n    buildData: BuildData;\r\n\r\n    beginPack(buildData: BuildData, bufFloat: Float32Array, bufUint: Uint32Array,\r\n        indices: Uint16Array, bufferPos = 0, indexPos = 0): void\r\n    {\r\n        this.buildData = buildData;\r\n        this.bufFloat = bufFloat;\r\n        this.bufUint = bufUint;\r\n        this.indices = indices;\r\n        this.bufferPos = bufferPos;\r\n        this.indexPos = indexPos;\r\n    }\r\n\r\n    endPack(): void\r\n    {\r\n        this.buildData = null;\r\n        this.bufFloat = null;\r\n        this.bufUint = null;\r\n        this.indices = null;\r\n    }\r\n\r\n    packInterleavedGeometry(jointStart: number, jointLen: number, triangles: number[],\r\n        lineStyle: number, color: number): void\r\n    {\r\n        const { bufFloat, bufUint, indices, buildData, strideFloats } = this;\r\n        const { joints, verts } = buildData;\r\n\r\n        let bufPos = this.bufferPos;\r\n        let indPos = this.indexPos;\r\n        let index = this.bufferPos / this.strideFloats;\r\n\r\n        // eslint-disable-next-line max-len\r\n        let x1: number; let y1: number;\r\n        let x2: number; let y2: number;\r\n        let prevX: number; let prevY: number;\r\n        let nextX: number; let nextY: number;\r\n        // let type: number;\r\n        let hasTriangle = false;\r\n\r\n        let travel = 0;\r\n\r\n        for (let j = jointStart; j < jointStart + jointLen; j++)\r\n        {\r\n            const fullJoint = joints[j];\r\n            const prevCap = joints[j] & ~31;\r\n            const joint = joints[j] & 31;\r\n\r\n            if (joint === JOINT_TYPE.FILL)\r\n            {\r\n                // just one vertex\r\n                hasTriangle = true;\r\n                x1 = verts[(j * 2)];\r\n                y1 = verts[(j * 2) + 1];\r\n                bufFloat[bufPos] = x1;\r\n                bufFloat[bufPos + 1] = y1;\r\n                bufFloat[bufPos + 2] = x1;\r\n                bufFloat[bufPos + 3] = y1;\r\n                bufFloat[bufPos + 4] = x1;\r\n                bufFloat[bufPos + 5] = y1;\r\n                bufFloat[bufPos + 6] = x1;\r\n                bufFloat[bufPos + 7] = y1;\r\n                bufFloat[bufPos + 8] = travel;\r\n                bufFloat[bufPos + 9] = 16 * joint;\r\n                bufFloat[bufPos + 10] = lineStyle;\r\n                bufUint[bufPos + 11] = color;\r\n                bufPos += strideFloats;\r\n                continue;\r\n            }\r\n\r\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\r\n            {\r\n                prevX = verts[j * 2];\r\n                prevY = verts[(j * 2) + 1];\r\n                x1 = verts[(j * 2) + 2];\r\n                y1 = verts[(j * 2) + 3];\r\n                x2 = verts[(j * 2) + 4];\r\n                y2 = verts[(j * 2) + 5];\r\n\r\n                const bis = j + 3;\r\n\r\n                for (let i = 0; i < 3; i++)\r\n                {\r\n                    bufFloat[bufPos] = prevX;\r\n                    bufFloat[bufPos + 1] = prevY;\r\n                    bufFloat[bufPos + 2] = x1;\r\n                    bufFloat[bufPos + 3] = y1;\r\n                    bufFloat[bufPos + 4] = x2;\r\n                    bufFloat[bufPos + 5] = y2;\r\n                    bufFloat[bufPos + 6] = verts[(bis + i) * 2];\r\n                    bufFloat[bufPos + 7] = verts[((bis + i) * 2) + 1];\r\n\r\n                    bufFloat[bufPos + 8] = travel;\r\n                    bufFloat[bufPos + 9] = (16 * fullJoint) + i;\r\n                    bufFloat[bufPos + 10] = lineStyle;\r\n                    bufUint[bufPos + 11] = color;\r\n                    bufPos += strideFloats;\r\n                }\r\n\r\n                indices[indPos] = index;\r\n                indices[indPos + 1] = index + 1;\r\n                indices[indPos + 2] = index + 2;\r\n                indPos += 3;\r\n                index += 3;\r\n                continue;\r\n            }\r\n\r\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\r\n\r\n            if (vs === 0)\r\n            {\r\n                continue;\r\n            }\r\n            x1 = verts[j * 2];\r\n            y1 = verts[(j * 2) + 1];\r\n            x2 = verts[(j * 2) + 2];\r\n            y2 = verts[(j * 2) + 3];\r\n            // TODO: caps here\r\n            prevX = verts[(j * 2) - 2];\r\n            prevY = verts[(j * 2) - 1];\r\n\r\n            const dist = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\r\n\r\n            if (SegmentPacker.vertsByJoint[joint] === 0)\r\n            {\r\n                travel -= dist;\r\n            }\r\n\r\n            if ((joint & ~2) !== JOINT_TYPE.JOINT_CAP_BUTT)\r\n            {\r\n                nextX = verts[(j * 2) + 4];\r\n                nextY = verts[(j * 2) + 5];\r\n            }\r\n            else\r\n            {\r\n                nextX = x1;\r\n                nextY = y1;\r\n            }\r\n            // type = joint;\r\n\r\n            for (let i = 0; i < vs; i++)\r\n            {\r\n                bufFloat[bufPos] = prevX;\r\n                bufFloat[bufPos + 1] = prevY;\r\n                bufFloat[bufPos + 2] = x1;\r\n                bufFloat[bufPos + 3] = y1;\r\n                bufFloat[bufPos + 4] = x2;\r\n                bufFloat[bufPos + 5] = y2;\r\n                bufFloat[bufPos + 6] = nextX;\r\n                bufFloat[bufPos + 7] = nextY;\r\n                bufFloat[bufPos + 8] = travel;\r\n                bufFloat[bufPos + 9] = (16 * fullJoint) + i;\r\n                bufFloat[bufPos + 10] = lineStyle;\r\n                bufUint[bufPos + 11] = color;\r\n                bufPos += strideFloats;\r\n            }\r\n\r\n            travel += dist;\r\n\r\n            indices[indPos] = index;\r\n            indices[indPos + 1] = index + 1;\r\n            indices[indPos + 2] = index + 2;\r\n            indices[indPos + 3] = index;\r\n            indices[indPos + 4] = index + 2;\r\n            indices[indPos + 5] = index + 3;\r\n            indPos += 6;\r\n            for (let j = 5; j + 1 < vs; j++)\r\n            {\r\n                indices[indPos] = index + 4;\r\n                indices[indPos + 1] = index + j;\r\n                indices[indPos + 2] = index + j + 1;\r\n                indPos += 3;\r\n            }\r\n            index += vs;\r\n        }\r\n\r\n        if (hasTriangle)\r\n        {\r\n            for (let i = 0; i < triangles.length; i++)\r\n            {\r\n                indices[indPos + i] = triangles[i] + index;\r\n            }\r\n            indPos += triangles.length;\r\n        }\r\n\r\n        this.bufferPos = bufPos;\r\n        this.indexPos = indPos;\r\n    }\r\n}\r\n\r\nconst verts = SegmentPacker.vertsByJoint;\r\n\r\nfor (let i = 0; i < 256; i++)\r\n{ verts.push(0); }\r\n// simple fill\r\nverts[JOINT_TYPE.FILL] = 1;\r\n\r\nfor (let i = 0; i < 8; i++)\r\n{\r\n    verts[JOINT_TYPE.FILL_EXPAND + i] = 3;\r\n}\r\n\r\n// no caps for now\r\nverts[JOINT_TYPE.JOINT_BEVEL] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_BEVEL + 1] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_BEVEL + 2] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_BEVEL + 3] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_ROUND] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_ROUND + 1] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_ROUND + 2] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_ROUND + 3] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_MITER] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_MITER + 1] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_MITER + 2] = 4;\r\nverts[JOINT_TYPE.JOINT_MITER + 3] = 4;\r\nverts[JOINT_TYPE.JOINT_CAP_BUTT] = 4;\r\nverts[JOINT_TYPE.JOINT_CAP_BUTT + 1] = 4;\r\nverts[JOINT_TYPE.JOINT_CAP_SQUARE] = 4;\r\nverts[JOINT_TYPE.JOINT_CAP_SQUARE + 1] = 4;\r\nverts[JOINT_TYPE.JOINT_CAP_ROUND] = 4 + 5;\r\nverts[JOINT_TYPE.JOINT_CAP_ROUND + 1] = 4 + 5;\r\n\r\nverts[JOINT_TYPE.CAP_ROUND] = 4;\r\n","import type { Matrix, SHAPES, IShape } from '@pixi/math';\r\nimport { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\r\nimport { JOINT_TYPE } from './const';\r\nimport { FillStyle } from './FillStyle';\r\nimport { LineStyle } from './LineStyle';\r\n\r\n/**\r\n * A class to contain data useful for Graphics objects\r\n *\r\n * @class\r\n * @memberof PIXI\r\n */\r\nexport class SmoothGraphicsData\r\n{\r\n    shape: IShape;\r\n    lineStyle: LineStyle;\r\n    fillStyle: FillStyle;\r\n    matrix: Matrix;\r\n    type: SHAPES;\r\n    holes: Array<SmoothGraphicsData>;\r\n\r\n    // result of simplification\r\n    closeStroke: boolean;\r\n    points: number[];\r\n    triangles: number[];\r\n    // indices in build\r\n    attribStart: number;\r\n    fillStart: number;\r\n    fillLen: number;\r\n    strokeStart: number;\r\n    strokeLen: number;\r\n    fillAA: boolean;\r\n\r\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\r\n    {\r\n        this.shape = shape;\r\n\r\n        this.lineStyle = lineStyle;\r\n\r\n        this.fillStyle = fillStyle;\r\n\r\n        this.matrix = matrix;\r\n\r\n        this.type = shape.type;\r\n\r\n        this.points = [];\r\n\r\n        this.holes = [];\r\n\r\n        this.triangles = [];\r\n\r\n        this.closeStroke = false;\r\n\r\n        this.clearBuild();\r\n    }\r\n\r\n    public clearPath()\r\n    {\r\n        this.points.length = 0;\r\n        this.closeStroke = true;\r\n    }\r\n\r\n    public clearBuild()\r\n    {\r\n        this.triangles.length = 0;\r\n        this.fillStart = 0;\r\n        this.fillLen = 0;\r\n        this.strokeStart = 0;\r\n        this.strokeLen = 0;\r\n        this.fillAA = false;\r\n    }\r\n\r\n    public clone(): SmoothGraphicsData\r\n    {\r\n        return new SmoothGraphicsData(\r\n            this.shape,\r\n            this.fillStyle,\r\n            this.lineStyle,\r\n            this.matrix\r\n        );\r\n    }\r\n\r\n    public capType()\r\n    {\r\n        let cap: number;\r\n\r\n        switch (this.lineStyle.cap)\r\n        {\r\n            case LINE_CAP.SQUARE:\r\n                cap = JOINT_TYPE.CAP_SQUARE;\r\n                break;\r\n            case LINE_CAP.ROUND:\r\n                cap = JOINT_TYPE.CAP_ROUND;\r\n                break;\r\n            default:\r\n                cap = JOINT_TYPE.CAP_BUTT;\r\n                break;\r\n        }\r\n\r\n        return cap;\r\n    }\r\n\r\n    public goodJointType() {\r\n        let joint: number;\r\n\r\n        switch (this.lineStyle.join)\r\n        {\r\n            case LINE_JOIN.BEVEL:\r\n                joint = JOINT_TYPE.JOINT_BEVEL;\r\n                break;\r\n            case LINE_JOIN.ROUND:\r\n                joint = JOINT_TYPE.JOINT_ROUND;\r\n                break;\r\n            default:\r\n                joint = JOINT_TYPE.JOINT_MITER + 3;\r\n                break;\r\n        }\r\n\r\n        return joint;\r\n    }\r\n\r\n    public jointType()\r\n    {\r\n        let joint: number;\r\n\r\n        switch (this.lineStyle.join)\r\n        {\r\n            case LINE_JOIN.BEVEL:\r\n                joint = JOINT_TYPE.JOINT_BEVEL;\r\n                break;\r\n            case LINE_JOIN.ROUND:\r\n                joint = JOINT_TYPE.JOINT_ROUND;\r\n                break;\r\n            default:\r\n                joint = JOINT_TYPE.JOINT_MITER;\r\n                break;\r\n        }\r\n\r\n        return joint;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        this.shape = null;\r\n        this.holes.length = 0;\r\n        this.holes = null;\r\n        this.points.length = 0;\r\n        this.points = null;\r\n        this.lineStyle = null;\r\n        this.fillStyle = null;\r\n        this.triangles = null;\r\n    }\r\n}\r\n","// for type only\r\nimport { SHAPES } from '@pixi/math';\r\n\r\nimport type { Circle, Ellipse } from '@pixi/math';\r\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nexport class CircleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        // need to convert points to a nice regular data\r\n        const circleData = graphicsData.shape as Circle;\r\n        const points = graphicsData.points;\r\n        const x = circleData.x;\r\n        const y = circleData.y;\r\n        let width;\r\n        let height;\r\n        // TODO - bit hacky??\r\n\r\n        if (graphicsData.type === SHAPES.CIRC)\r\n        {\r\n            width = circleData.radius;\r\n            height = circleData.radius;\r\n        }\r\n        else\r\n        {\r\n            const ellipseData = graphicsData.shape as Ellipse;\r\n\r\n            width = ellipseData.width;\r\n            height = ellipseData.height;\r\n        }\r\n\r\n        if (width <= 0 || height <= 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\r\n            || Math.floor(15 * Math.sqrt(width + height));\r\n\r\n        totalSegs /= 2.3;\r\n        if (totalSegs < 3)\r\n        {\r\n            totalSegs = 3;\r\n        }\r\n        else\r\n        {\r\n            totalSegs = Math.ceil(totalSegs);\r\n        }\r\n\r\n        const seg = (Math.PI * 2) / totalSegs;\r\n\r\n        for (let i = 0; i < totalSegs; i++)\r\n        {\r\n            points.push(\r\n                x + (Math.sin(-seg * i) * width),\r\n                y + (Math.cos(-seg * i) * height)\r\n            );\r\n        }\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData)\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points, triangles } = graphicsData;\r\n\r\n        let vertPos = 1;\r\n        const center = 0;\r\n\r\n        const circle = graphicsData.shape as Circle;\r\n        const matrix = graphicsData.matrix;\r\n        const x = circle.x;\r\n        const y = circle.y;\r\n        const cx = matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x;\r\n        const cy = matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y;\r\n\r\n        if (!graphicsData.fillAA)\r\n        {\r\n            verts.push(cx, cy);\r\n            joints.push(JOINT_TYPE.FILL);\r\n\r\n            for (let i = 0; i < points.length; i += 2)\r\n            {\r\n                verts.push(points[i], points[i + 1]);\r\n                joints.push(JOINT_TYPE.FILL);\r\n                if (i > 0)\r\n                {\r\n                    triangles.push(vertPos++, center, vertPos);\r\n                }\r\n            }\r\n            triangles.push(vertPos, center, 1);\r\n\r\n            return;\r\n        }\r\n\r\n        const rad = circle.radius;\r\n\r\n        for (let i = 0; i < points.length; i += 2)\r\n        {\r\n            // const prev = i;\r\n            const cur = i;\r\n            const next = i + 2 < points.length ? i + 2 : 0;\r\n\r\n            verts.push(cx);\r\n            verts.push(cy);\r\n            verts.push(points[cur]);\r\n            verts.push(points[cur + 1]);\r\n            verts.push(points[next]);\r\n            verts.push(points[next + 1]);\r\n\r\n            verts.push(0);\r\n            verts.push(0);\r\n            verts.push((points[cur] - cx) / rad);\r\n            verts.push((points[cur + 1] - cy) / rad);\r\n            verts.push((points[next] - cx) / rad);\r\n            verts.push((points[next + 1] - cy) / rad);\r\n\r\n            joints.push(JOINT_TYPE.FILL_EXPAND + 2);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n        }\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n        const joint = graphicsData.goodJointType();\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n}\r\n","import type { Rectangle } from '@pixi/math';\r\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nexport class RectangleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        // --- //\r\n        // need to convert points to a nice regular data\r\n        //\r\n        const rectData = graphicsData.shape as Rectangle;\r\n        const x = rectData.x;\r\n        const y = rectData.y;\r\n        const width = rectData.width;\r\n        const height = rectData.height;\r\n        const points = graphicsData.points;\r\n\r\n        points.length = 0;\r\n\r\n        points.push(x, y,\r\n            x + width, y,\r\n            x + width, y + height,\r\n            x, y + height);\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        const joint = graphicsData.goodJointType();\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points, triangles } = graphicsData;\r\n\r\n        triangles.length = 0;\r\n\r\n        verts.push(points[0], points[1],\r\n            points[2], points[3],\r\n            points[4], points[5],\r\n            points[6], points[7]);\r\n\r\n        joints.push(JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL);\r\n        triangles.push(0, 1, 2, 0, 2, 3);\r\n    }\r\n}\r\n","import type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { RoundedRectangle } from '@pixi/math';\r\nimport { earcut } from '@pixi/utils';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nfunction getPt(n1: number, n2: number, perc: number): number\r\n{\r\n    const diff = n2 - n1;\r\n\r\n    return n1 + (diff * perc);\r\n}\r\n\r\nfunction quadraticBezierCurve(\r\n    fromX: number, fromY: number,\r\n    cpX: number, cpY: number,\r\n    toX: number, toY: number,\r\n    out: Array<number> = [],\r\n    eps = 0.001): Array<number>\r\n{\r\n    const n = 20;\r\n    const points = out;\r\n\r\n    let xa = 0;\r\n    let ya = 0;\r\n    let xb = 0;\r\n    let yb = 0;\r\n    let x = 0;\r\n    let y = 0;\r\n\r\n    for (let i = 0, j = 0; i <= n; ++i)\r\n    {\r\n        j = i / n;\r\n\r\n        // The Green Line\r\n        xa = getPt(fromX, cpX, j);\r\n        ya = getPt(fromY, cpY, j);\r\n        xb = getPt(cpX, toX, j);\r\n        yb = getPt(cpY, toY, j);\r\n\r\n        // The Black Dot\r\n        x = getPt(xa, xb, j);\r\n        y = getPt(ya, yb, j);\r\n\r\n        // Handle case when first curve points overlaps and earcut fails to triangulate\r\n        if (i === 0\r\n            && Math.abs(x - points[points.length - 2]) < eps\r\n            && Math.abs(y - points[points.length - 1]) < eps)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        points.push(x, y);\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\nexport class RoundedRectangleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        const rrectData = graphicsData.shape as RoundedRectangle;\r\n        const { points } = graphicsData;\r\n        const x = rrectData.x;\r\n        const y = rrectData.y;\r\n        const width = rrectData.width;\r\n        const height = rrectData.height;\r\n\r\n        // Don't allow negative radius or greater than half the smallest width\r\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\r\n\r\n        points.length = 0;\r\n\r\n        // No radius, do a simple rectangle\r\n        if (!radius)\r\n        {\r\n            points.push(x, y,\r\n                x + width, y,\r\n                x + width, y + height,\r\n                x, y + height);\r\n        }\r\n        else\r\n        {\r\n            const eps = _target.closePointEps;\r\n\r\n            quadraticBezierCurve(x, y + radius,\r\n                x, y,\r\n                x + radius, y,\r\n                points, eps);\r\n            quadraticBezierCurve(x + width - radius,\r\n                y, x + width, y,\r\n                x + width, y + radius,\r\n                points, eps);\r\n            quadraticBezierCurve(x + width, y + height - radius,\r\n                x + width, y + height,\r\n                x + width - radius, y + height,\r\n                points, eps);\r\n            quadraticBezierCurve(x + radius, y + height,\r\n                x, y + height,\r\n                x, y + height - radius,\r\n                points, eps);\r\n\r\n            if (points.length >= 4\r\n                && Math.abs(points[0] - points[points.length - 2]) < eps\r\n                && Math.abs(points[1] - points[points.length - 1]) < eps)\r\n            {\r\n                points.pop();\r\n                points.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        const joint = points.length === 8 // we dont need joints for arcs\r\n            ? graphicsData.goodJointType() : JOINT_TYPE.JOINT_MITER + 3;\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        graphicsData.triangles = earcut(points, null, 2);\r\n\r\n        for (let i = 0, j = points.length; i < j; i++)\r\n        {\r\n            verts.push(points[i], points[++i]);\r\n            joints.push(JOINT_TYPE.FILL);\r\n        }\r\n    }\r\n}\r\n","import type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { JOINT_TYPE } from '../core/const';\r\nimport { Point, Polygon } from '@pixi/math';\r\nimport { earcut } from '@pixi/utils';\r\n\r\nconst tempArr: Array<number> = [];\r\n\r\nexport class PolyBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, buildData: BuildData)\r\n    {\r\n        const shape = graphicsData.shape as Polygon;\r\n        const points = graphicsData.points = shape.points.slice();\r\n        const eps = buildData.closePointEps;\r\n        const eps2 = eps * eps;\r\n\r\n        if (points.length === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const firstPoint = new Point(points[0], points[1]);\r\n        const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\r\n        const closedShape = graphicsData.closeStroke = shape.closeStroke;\r\n\r\n        let len = points.length;\r\n        let newLen = 2;\r\n\r\n        // 1. remove equal points\r\n        for (let i = 2; i < len; i += 2)\r\n        {\r\n            const x1 = points[i - 2]; const y1 = points[i - 1]; const x2 = points[i]; const\r\n                y2 = points[i + 1];\r\n            let flag = true;\r\n\r\n            if (Math.abs(x1 - x2) < eps\r\n                && Math.abs(y1 - y2) < eps)\r\n            {\r\n                flag = false;\r\n            }\r\n\r\n            if (flag)\r\n            {\r\n                points[newLen] = points[i];\r\n                points[newLen + 1] = points[i + 1];\r\n                newLen += 2;\r\n            }\r\n        }\r\n        points.length = len = newLen;\r\n\r\n        newLen = 2;\r\n        // 2. remove middle points\r\n        for (let i = 2; i + 2 < len; i += 2)\r\n        {\r\n            let x1 = points[i - 2]; let y1 = points[i - 1]; const x2 = points[i]; const y2 = points[i + 1];\r\n            let x3 = points[i + 2]; let\r\n                y3 = points[i + 3];\r\n\r\n            x1 -= x2;\r\n            y1 -= y2;\r\n            x3 -= x2;\r\n            y3 -= y2;\r\n            let flag = true;\r\n\r\n            if (Math.abs(x3 * y1 - y3 * x1) < eps2)\r\n            {\r\n                if (x1 * x3 + y1 * y3 < -eps2)\r\n                {\r\n                    flag = false;\r\n                }\r\n            }\r\n\r\n            if (flag)\r\n            {\r\n                points[newLen] = points[i];\r\n                points[newLen + 1] = points[i + 1];\r\n                newLen += 2;\r\n            }\r\n        }\r\n        points[newLen] = points[len - 2];\r\n        points[newLen + 1] = points[len - 1];\r\n        newLen += 2;\r\n\r\n        points.length = len = newLen;\r\n\r\n        if (len <= 2)\r\n        {\r\n            // suddenly, nothing\r\n            return;\r\n        }\r\n\r\n        if (closedShape)\r\n        {\r\n            // first point should be last point in closed line!\r\n            const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\r\n                && Math.abs(firstPoint.y - lastPoint.y) < eps;\r\n\r\n            if (closedPath)\r\n            {\r\n                points.pop();\r\n                points.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, buildData: BuildData)\r\n    {\r\n        const { closeStroke, points } = graphicsData;\r\n        const eps = buildData.closePointEps;\r\n        // const eps2 = eps * eps;\r\n        const len = points.length;\r\n        // const style = graphicsData.lineStyle;\r\n\r\n        if (len <= 2)\r\n        {\r\n            return;\r\n        }\r\n        const { verts, joints } = buildData;\r\n\r\n        // TODO: alignment\r\n\r\n        const joint = graphicsData.jointType();\r\n        const cap = graphicsData.capType();\r\n        let prevCap = 0;\r\n\r\n        let prevX: number; let\r\n            prevY: number;\r\n\r\n        if (closeStroke)\r\n        {\r\n            prevX = points[len - 2];\r\n            prevY = points[len - 1];\r\n            joints.push(JOINT_TYPE.NONE);\r\n        }\r\n        else\r\n        {\r\n            prevX = points[2];\r\n            prevY = points[3];\r\n            if (cap === JOINT_TYPE.CAP_ROUND)\r\n            {\r\n                verts.push(points[0], points[1]);\r\n                joints.push(JOINT_TYPE.NONE);\r\n                joints.push(JOINT_TYPE.CAP_ROUND);\r\n                prevCap = 0;\r\n            }\r\n            else\r\n            {\r\n                prevCap = cap;\r\n                joints.push(JOINT_TYPE.NONE);\r\n            }\r\n        }\r\n        verts.push(prevX, prevY);\r\n\r\n        /* Line segments of interest where (x1,y1) forms the corner. */\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            const x1 = points[i]; const\r\n                y1 = points[i + 1];\r\n\r\n            let x2: number; let\r\n                y2: number;\r\n\r\n            if (i + 2 < len)\r\n            {\r\n                x2 = points[i + 2];\r\n                y2 = points[i + 3];\r\n            }\r\n            else\r\n            {\r\n                x2 = points[0];\r\n                y2 = points[1];\r\n            }\r\n\r\n            const dx = x2 - x1;\r\n            const dy = y2 - y1;\r\n            let nextX: number; let\r\n                nextY: number;\r\n\r\n            let endJoint = joint;\r\n\r\n            if (i + 2 >= len)\r\n            {\r\n                nextX = points[2];\r\n                nextY = points[3];\r\n                if (!closeStroke)\r\n                {\r\n                    endJoint = JOINT_TYPE.NONE;\r\n                }\r\n            }\r\n            else if (i + 4 >= len)\r\n            {\r\n                nextX = points[0];\r\n                nextY = points[1];\r\n                if (!closeStroke)\r\n                {\r\n                    if (cap === JOINT_TYPE.CAP_ROUND)\r\n                    {\r\n                        endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\r\n                    }\r\n                    if (cap === JOINT_TYPE.CAP_BUTT)\r\n                    {\r\n                        endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\r\n                    }\r\n                    if (cap === JOINT_TYPE.CAP_SQUARE)\r\n                    {\r\n                        endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                nextX = points[i + 4];\r\n                nextY = points[i + 5];\r\n            }\r\n\r\n            const dx3 = x1 - prevX;\r\n            const dy3 = y1 - prevY;\r\n\r\n            if (joint >= JOINT_TYPE.JOINT_BEVEL && joint <= JOINT_TYPE.JOINT_MITER)\r\n            {\r\n                const dx2 = nextX - x2;\r\n                const dy2 = nextY - y2;\r\n\r\n                if (endJoint >= JOINT_TYPE.JOINT_BEVEL\r\n                    && endJoint <= JOINT_TYPE.JOINT_MITER + 3)\r\n                {\r\n                    const D = dx2 * dy - dy2 * dx;\r\n\r\n                    if (Math.abs(D) < eps)\r\n                    {\r\n                        switch (joint & ~3)\r\n                        {\r\n                            case JOINT_TYPE.JOINT_ROUND:\r\n                                endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\r\n                                break;\r\n                            default:\r\n                                endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (joint === JOINT_TYPE.JOINT_MITER)\r\n                {\r\n                    let jointAdd = 0;\r\n\r\n                    if (dx3 * dx + dy3 * dy > -eps)\r\n                    {\r\n                        jointAdd++;\r\n                    }\r\n                    if (endJoint === JOINT_TYPE.JOINT_MITER && dx2 * dx + dy2 * dy > -eps)\r\n                    {\r\n                        jointAdd += 2;\r\n                    }\r\n                    endJoint += jointAdd;\r\n                }\r\n            }\r\n            if (prevCap === 0)\r\n            {\r\n                if (Math.abs(dx3 * dy - dy3 * dx) < eps)\r\n                {\r\n                    prevCap = JOINT_TYPE.CAP_BUTT2;\r\n                }\r\n            }\r\n            endJoint += prevCap;\r\n            prevCap = 0;\r\n\r\n            verts.push(x1, y1);\r\n            joints.push(endJoint);\r\n\r\n            prevX = x1;\r\n            prevY = y1;\r\n        }\r\n\r\n        if (closeStroke)\r\n        {\r\n            verts.push(points[0], points[1]);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            verts.push(points[2], points[3]);\r\n            joints.push(JOINT_TYPE.NONE);\r\n        }\r\n        else\r\n        {\r\n            verts.push(points[len - 4], points[len - 3]);\r\n            joints.push(JOINT_TYPE.NONE);\r\n        }\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, buildData: BuildData)\r\n    {\r\n        let points = graphicsData.points;\r\n        // TODO: simplify holes too!\r\n        const holes = graphicsData.holes;\r\n        const eps = buildData.closePointEps;\r\n\r\n        const { verts, joints } = buildData;\r\n\r\n        if (points.length < 6)\r\n        {\r\n            return;\r\n        }\r\n        const holeArray = [];\r\n        let len = points.length;\r\n        // Process holes..\r\n\r\n        for (let i = 0; i < holes.length; i++)\r\n        {\r\n            const hole = holes[i];\r\n\r\n            holeArray.push(points.length / 2);\r\n            points = points.concat(hole.points);\r\n        }\r\n\r\n        // TODO: reduce size later?\r\n        const pn = tempArr;\r\n\r\n        if (pn.length < points.length)\r\n        {\r\n            pn.length = points.length;\r\n        }\r\n        let start = 0;\r\n\r\n        for (let i = 0; i <= holeArray.length; i++)\r\n        {\r\n            let finish = len / 2;\r\n\r\n            if (i > 0)\r\n            {\r\n                if (i < holeArray.length)\r\n                {\r\n                    finish = holeArray[i];\r\n                }\r\n                else\r\n                {\r\n                    finish = (points.length >> 1);\r\n                }\r\n            }\r\n            pn[start * 2] = finish - 1;\r\n            pn[(finish - 1) * 2 + 1] = 0;\r\n            for (let j = start; j + 1 < finish; j++)\r\n            {\r\n                pn[j * 2 + 1] = j + 1;\r\n                pn[j * 2 + 2] = j;\r\n            }\r\n            start = finish;\r\n        }\r\n\r\n        // sort color\r\n        graphicsData.triangles = earcut(points, holeArray, 2);\r\n\r\n        if (!graphicsData.triangles)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!graphicsData.fillAA)\r\n        {\r\n            for (let i = 0; i < points.length; i += 2)\r\n            {\r\n                verts.push(points[i], points[i + 1]);\r\n                joints.push(JOINT_TYPE.FILL);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const { triangles } = graphicsData;\r\n\r\n        len = points.length;\r\n\r\n        for (let i = 0; i < triangles.length; i += 3)\r\n        {\r\n            // TODO: holes prev/next!!!\r\n            let flag = 0;\r\n\r\n            for (let j = 0; j < 3; j++)\r\n            {\r\n                const ind1 = triangles[i + j];\r\n                const ind2 = triangles[i + (j + 1) % 3];\r\n\r\n                if (pn[ind1 * 2] === ind2 || pn[ind1 * 2 + 1] === ind2)\r\n                {\r\n                    flag |= (1 << j);\r\n                }\r\n            }\r\n            joints.push(JOINT_TYPE.FILL_EXPAND + flag);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n            joints.push(JOINT_TYPE.NONE);\r\n        }\r\n\r\n        // bisect, re-using pn\r\n        for (let ind = 0; ind < len / 2; ind++)\r\n        {\r\n            const prev = pn[ind * 2];\r\n            const next = pn[ind * 2 + 1];\r\n            let nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); let\r\n                ny1 = -(points[next * 2] - points[ind * 2]);\r\n            let nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); let\r\n                ny2 = -(points[ind * 2] - points[prev * 2]);\r\n            const D1 = Math.sqrt(nx1 * nx1 + ny1 * ny1);\r\n\r\n            nx1 /= D1;\r\n            ny1 /= D1;\r\n            const D2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\r\n\r\n            nx2 /= D2;\r\n            ny2 /= D2;\r\n\r\n            let bx = (nx1 + nx2);\r\n            let by = (ny1 + ny2);\r\n            const D = bx * nx1 + by * ny1;\r\n\r\n            if (Math.abs(D) < eps)\r\n            {\r\n                bx = nx1;\r\n                by = ny1;\r\n            }\r\n            else\r\n            {\r\n                bx /= D;\r\n                by /= D;\r\n            }\r\n            pn[ind * 2] = bx;\r\n            pn[ind * 2 + 1] = by;\r\n        }\r\n\r\n        for (let i = 0; i < triangles.length; i += 3)\r\n        {\r\n            const prev = triangles[i];\r\n            const ind = triangles[i + 1];\r\n            const next = triangles[i + 2];\r\n            const nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); const\r\n                ny1 = -(points[next * 2] - points[ind * 2]);\r\n            const nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); const\r\n                ny2 = -(points[ind * 2] - points[prev * 2]);\r\n\r\n            let j1 = 1;\r\n\r\n            if (nx1 * ny2 - nx2 * ny1 > 0.0)\r\n            {\r\n                j1 = 2;\r\n            }\r\n\r\n            for (let j = 0; j < 3; j++)\r\n            {\r\n                const ind = triangles[i + (j * j1) % 3];\r\n\r\n                verts.push(points[ind * 2], points[ind * 2 + 1]);\r\n            }\r\n            for (let j = 0; j < 3; j++)\r\n            {\r\n                const ind = triangles[i + (j * j1) % 3];\r\n\r\n                verts.push(pn[ind * 2], pn[ind * 2 + 1]);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { SHAPES } from '@pixi/math';\r\nimport { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { CircleBuilder } from './CircleBuilder';\r\nimport { RectangleBuilder } from './RectangleBuilder';\r\nimport { RoundedRectangleBuilder } from './RoundedRectangleBuilder';\r\nimport { PolyBuilder } from './PolyBuilder';\r\n\r\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuilder> = {\r\n    [SHAPES.POLY]: new PolyBuilder(),\r\n    [SHAPES.CIRC]: new CircleBuilder(),\r\n    [SHAPES.ELIP]: new CircleBuilder(),\r\n    [SHAPES.RECT]: new RectangleBuilder(),\r\n    [SHAPES.RREC]: new RoundedRectangleBuilder()\r\n};\r\n\r\nexport { CircleBuilder, RectangleBuilder, RoundedRectangleBuilder, PolyBuilder };\r\n","import { SmoothGraphicsData } from './core/SmoothGraphicsData';\r\n\r\nimport { FILL_COMMANDS } from './shapes';\r\n\r\nimport {\r\n    Buffer,\r\n    Geometry,\r\n} from '@pixi/core';\r\n\r\nimport { WRAP_MODES, TYPES } from '@pixi/constants';\r\nimport { SHAPES, Point, Matrix } from '@pixi/math';\r\nimport { premultiplyTint } from '@pixi/utils';\r\nimport { Bounds } from '@pixi/display';\r\n\r\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData } from '@pixi/math';\r\nimport { BuildData } from './core/BuildData';\r\nimport { SegmentPacker } from './core/SegmentPacker';\r\nimport { LineStyle } from './core/LineStyle';\r\nimport { FillStyle } from './core/FillStyle';\r\nimport { BatchPart } from './core/BatchPart';\r\nimport { BatchDrawCall, IGraphicsBatchSettings, matrixEquals } from './core/BatchDrawCall';\r\n\r\n/*\r\n * Complex shape type\r\n * @todo Move to Math shapes\r\n */\r\nexport type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\r\n\r\nexport const BATCH_POOL: Array<BatchPart> = [];\r\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\r\n\r\nconst tmpPoint = new Point();\r\nconst tmpBounds = new Bounds();\r\n\r\nexport class SmoothGraphicsGeometry extends Geometry\r\n{\r\n    public static BATCHABLE_SIZE = 100;\r\n\r\n    public boundsPadding: number;\r\n\r\n    indicesUint16: Uint16Array | Uint32Array = null;\r\n    batchable: boolean;\r\n\r\n    buildData: BuildData;\r\n\r\n    get points()\r\n    {\r\n        return this.buildData.verts;\r\n    }\r\n\r\n    get closePointEps()\r\n    {\r\n        return this.buildData.closePointEps;\r\n    }\r\n\r\n    graphicsData: Array<SmoothGraphicsData>;\r\n    drawCalls: Array<BatchDrawCall>;\r\n    batchDirty: number;\r\n    batches: Array<BatchPart>;\r\n    packer: SegmentPacker;\r\n    packSize: number;\r\n    pack32index: boolean;\r\n    strideFloats: number;\r\n\r\n    protected dirty: number;\r\n    protected cacheDirty: number;\r\n    protected clearDirty: number;\r\n    protected shapeBuildIndex: number;\r\n    protected shapeBatchIndex: number;\r\n    protected _bounds: Bounds;\r\n    protected boundsDirty: number;\r\n\r\n    _buffer: Buffer;\r\n    _indexBuffer: Buffer;\r\n    _bufferFloats: Float32Array;\r\n    _bufferUint: Uint32Array;\r\n\r\n    initAttributes(_static: boolean)\r\n    {\r\n        this._buffer = new Buffer(null, _static, false);\r\n        this._bufferFloats = new Float32Array();\r\n        this._bufferUint = new Uint32Array();\r\n\r\n        this._indexBuffer = new Buffer(null, _static, true);\r\n        this.addAttribute('aPrev', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aPoint1', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aPoint2', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aNext', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aTravel', this._buffer, 1, false, TYPES.FLOAT)\r\n            // number of vertex\r\n            .addAttribute('aVertexJoint', this._buffer, 1, false, TYPES.FLOAT)\r\n            // line width, alignment\r\n            .addAttribute('aStyleId', this._buffer, 1, false, TYPES.FLOAT)\r\n            // the usual\r\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\r\n            .addIndex(this._indexBuffer);\r\n\r\n        this.strideFloats = 12;\r\n    }\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this.initAttributes(false);\r\n\r\n        this.buildData = new BuildData();\r\n\r\n        this.graphicsData = [];\r\n\r\n        this.dirty = 0;\r\n\r\n        this.batchDirty = -1;\r\n\r\n        this.cacheDirty = -1;\r\n\r\n        this.clearDirty = 0;\r\n\r\n        this.drawCalls = [];\r\n\r\n        this.batches = [];\r\n\r\n        this.shapeBuildIndex = 0;\r\n\r\n        this.shapeBatchIndex = 0;\r\n\r\n        this._bounds = new Bounds();\r\n\r\n        this.boundsDirty = -1;\r\n\r\n        this.boundsPadding = 0;\r\n\r\n        this.batchable = false;\r\n\r\n        this.indicesUint16 = null;\r\n\r\n        this.packer = null;\r\n        this.packSize = 0;\r\n        this.pack32index = null;\r\n    }\r\n\r\n    public checkInstancing(instanced: boolean, allow32Indices: boolean)\r\n    {\r\n        if (this.packer)\r\n        {\r\n            return;\r\n        }\r\n        this.packer = new SegmentPacker();\r\n        this.pack32index = allow32Indices;\r\n    }\r\n\r\n    /**\r\n     * Get the current bounds of the graphic geometry.\r\n     *\r\n     * @member {PIXI.Bounds}\r\n     * @readonly\r\n     */\r\n    public get bounds(): Bounds\r\n    {\r\n        if (this.boundsDirty !== this.dirty)\r\n        {\r\n            this.boundsDirty = this.dirty;\r\n            this.calculateBounds();\r\n        }\r\n\r\n        return this._bounds;\r\n    }\r\n\r\n    /**\r\n     * Call if you changed graphicsData manually.\r\n     * Empties all batch buffers.\r\n     */\r\n    protected invalidate(): void\r\n    {\r\n        this.boundsDirty = -1;\r\n        this.dirty++;\r\n        this.batchDirty++;\r\n        this.shapeBuildIndex = 0;\r\n        this.shapeBatchIndex = 0;\r\n        this.packSize = 0;\r\n\r\n        this.buildData.clear();\r\n\r\n        for (let i = 0; i < this.drawCalls.length; i++)\r\n        {\r\n            this.drawCalls[i].clear();\r\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\r\n        }\r\n\r\n        this.drawCalls.length = 0;\r\n\r\n        for (let i = 0; i < this.batches.length; i++)\r\n        {\r\n            const batchPart = this.batches[i];\r\n\r\n            batchPart.reset();\r\n            BATCH_POOL.push(batchPart);\r\n        }\r\n\r\n        this.batches.length = 0;\r\n    }\r\n\r\n    public clear(): SmoothGraphicsGeometry\r\n    {\r\n        if (this.graphicsData.length > 0)\r\n        {\r\n            this.invalidate();\r\n            this.clearDirty++;\r\n            this.graphicsData.length = 0;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public drawShape(\r\n        shape: IShape,\r\n        fillStyle: FillStyle = null,\r\n        lineStyle: LineStyle = null,\r\n        matrix: Matrix = null): SmoothGraphicsGeometry\r\n    {\r\n        const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);\r\n\r\n        this.graphicsData.push(data);\r\n        this.dirty++;\r\n\r\n        return this;\r\n    }\r\n\r\n    public drawHole(shape: IShape, matrix: Matrix = null): SmoothGraphicsGeometry\r\n    {\r\n        if (!this.graphicsData.length)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        const data = new SmoothGraphicsData(shape, null, null, matrix);\r\n\r\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\r\n\r\n        data.lineStyle = lastShape.lineStyle;\r\n\r\n        lastShape.holes.push(data);\r\n\r\n        this.dirty++;\r\n\r\n        return this;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        super.destroy();\r\n\r\n        // destroy each of the SmoothGraphicsData objects\r\n        for (let i = 0; i < this.graphicsData.length; ++i)\r\n        {\r\n            this.graphicsData[i].destroy();\r\n        }\r\n\r\n        this.buildData.destroy();\r\n        this.buildData = null;\r\n        this.indexBuffer.destroy();\r\n        this.indexBuffer = null;\r\n        this.graphicsData.length = 0;\r\n        this.graphicsData = null;\r\n        this.drawCalls.length = 0;\r\n        this.drawCalls = null;\r\n        this.batches.length = 0;\r\n        this.batches = null;\r\n        this._bounds = null;\r\n    }\r\n\r\n    /**\r\n     * Check to see if a point is contained within this geometry.\r\n     *\r\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\r\n     * @return {Boolean} `true` if the point is contained within geometry.\r\n     */\r\n    public containsPoint(point: IPointData): boolean\r\n    {\r\n        const graphicsData = this.graphicsData;\r\n\r\n        for (let i = 0; i < graphicsData.length; ++i)\r\n        {\r\n            const data = graphicsData[i];\r\n\r\n            if (!data.fillStyle.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // only deal with fills..\r\n            if (data.shape)\r\n            {\r\n                if (data.matrix)\r\n                {\r\n                    data.matrix.applyInverse(point, tmpPoint);\r\n                }\r\n                else\r\n                {\r\n                    tmpPoint.copyFrom(point);\r\n                }\r\n\r\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\r\n                {\r\n                    let hitHole = false;\r\n\r\n                    if (data.holes)\r\n                    {\r\n                        for (let i = 0; i < data.holes.length; i++)\r\n                        {\r\n                            const hole = data.holes[i];\r\n\r\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\r\n                            {\r\n                                hitHole = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!hitHole)\r\n                    {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    updatePoints(): void\r\n    {\r\n        // do nothing\r\n    }\r\n\r\n    updateBufferSize(): void\r\n    {\r\n        this._buffer.update(new Float32Array());\r\n    }\r\n\r\n    updateBuild(): void\r\n    {\r\n        const { graphicsData, buildData } = this;\r\n        const len = graphicsData.length;\r\n\r\n        for (let i = this.shapeBuildIndex; i < len; i++)\r\n        {\r\n            const data = graphicsData[i];\r\n\r\n            data.strokeStart = 0;\r\n            data.strokeLen = 0;\r\n            data.fillStart = 0;\r\n            data.fillLen = 0;\r\n            const { fillStyle, lineStyle, holes } = data;\r\n\r\n            if (!fillStyle.visible && !lineStyle.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const command = FILL_COMMANDS[data.type];\r\n\r\n            data.clearPath();\r\n\r\n            command.path(data, buildData);\r\n            if (data.matrix)\r\n            {\r\n                this.transformPoints(data.points, data.matrix);\r\n            }\r\n\r\n            data.clearBuild();\r\n            if (data.points.length <= 2)\r\n            {\r\n                continue;\r\n            }\r\n            if (fillStyle.visible)\r\n            {\r\n                data.fillAA = (data.fillStyle as any).smooth\r\n                    && !(data.lineStyle.visible\r\n                    && data.lineStyle.alpha >= 0.99\r\n                    && data.lineStyle.width >= 0.99);\r\n\r\n                data.fillStart = buildData.joints.length;\r\n\r\n                if (holes.length)\r\n                {\r\n                    this.processHoles(holes);\r\n\r\n                    FILL_COMMANDS[SHAPES.POLY].fill(data, buildData);\r\n                }\r\n                else\r\n                {\r\n                    if (data.fillAA && (data.type === SHAPES.RECT || data.type === SHAPES.RREC))\r\n                    {\r\n                        FILL_COMMANDS[SHAPES.POLY].fill(data, buildData);\r\n                    }\r\n                    else\r\n                    {\r\n                        command.fill(data, buildData);\r\n                    }\r\n                }\r\n\r\n                data.fillLen = buildData.joints.length - data.fillStart;\r\n            }\r\n            if (lineStyle.visible)\r\n            {\r\n                data.strokeStart = buildData.joints.length;\r\n                command.line(data, buildData);\r\n                for (let i = 0; i < holes.length; i++)\r\n                {\r\n                    command.line(holes[i], buildData);\r\n                }\r\n                data.strokeLen = buildData.joints.length - data.strokeStart;\r\n            }\r\n        }\r\n        this.shapeBuildIndex = len;\r\n    }\r\n\r\n    updateBatches(shaderSettings?: IGraphicsBatchSettings): void\r\n    {\r\n        if (!this.graphicsData.length)\r\n        {\r\n            this.batchable = true;\r\n\r\n            return;\r\n        }\r\n        this.updateBuild();\r\n\r\n        if (!this.validateBatching())\r\n        {\r\n            return;\r\n        }\r\n\r\n        const { buildData, graphicsData } = this;\r\n        const len = graphicsData.length;\r\n\r\n        this.cacheDirty = this.dirty;\r\n\r\n        let batchPart: BatchPart = null;\r\n\r\n        let currentStyle = null;\r\n\r\n        if (this.batches.length > 0)\r\n        {\r\n            batchPart = this.batches[this.batches.length - 1];\r\n            currentStyle = batchPart.style;\r\n        }\r\n\r\n        for (let i = this.shapeBatchIndex; i < len; i++)\r\n        {\r\n            const data = graphicsData[i];\r\n            const fillStyle = data.fillStyle;\r\n            const lineStyle = data.lineStyle;\r\n\r\n            if (data.matrix)\r\n            {\r\n                this.transformPoints(data.points, data.matrix);\r\n            }\r\n            if (!fillStyle.visible && !lineStyle.visible)\r\n            {\r\n                continue;\r\n            }\r\n            for (let j = 0; j < 2; j++)\r\n            {\r\n                const style = (j === 0) ? fillStyle : lineStyle;\r\n\r\n                if (!style.visible) continue;\r\n\r\n                const nextTexture = style.texture.baseTexture;\r\n                const attribOld = buildData.vertexSize;\r\n                const indexOld = buildData.indexSize;\r\n\r\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\r\n                if (j === 0)\r\n                {\r\n                    this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);\r\n                }\r\n                else\r\n                {\r\n                    this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);\r\n                }\r\n\r\n                const attribSize = buildData.vertexSize;\r\n\r\n                if (attribSize === attribOld) continue;\r\n                // close batch if style is different\r\n                if (batchPart && !this._compareStyles(currentStyle, style))\r\n                {\r\n                    batchPart.end(indexOld, attribOld);\r\n                    batchPart = null;\r\n                }\r\n                // spawn new batch if its first batch or previous was closed\r\n                if (!batchPart)\r\n                {\r\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\r\n                    batchPart.begin(style, indexOld, attribOld);\r\n                    this.batches.push(batchPart);\r\n                    currentStyle = style;\r\n                }\r\n\r\n                if (j === 0)\r\n                {\r\n                    batchPart.jointEnd = data.fillStart + data.fillLen;\r\n                }\r\n                else\r\n                {\r\n                    batchPart.jointEnd = data.strokeStart + data.strokeLen;\r\n                }\r\n            }\r\n        }\r\n        this.shapeBatchIndex = len;\r\n\r\n        if (batchPart)\r\n        {\r\n            batchPart.end(buildData.indexSize, buildData.vertexSize);\r\n        }\r\n\r\n        if (this.batches.length === 0)\r\n        {\r\n            // there are no visible styles in SmoothGraphicsData\r\n            // its possible that someone wants Graphics just for the bounds\r\n            this.batchable = true;\r\n\r\n            return;\r\n        }\r\n\r\n        // TODO make this a const..\r\n        this.batchable = this.isBatchable();\r\n\r\n        if (this.batchable)\r\n        {\r\n            this.packBatches();\r\n        }\r\n        else\r\n        {\r\n            this.buildDrawCalls(shaderSettings);\r\n            this.updatePack();\r\n        }\r\n    }\r\n\r\n    updatePack()\r\n    {\r\n        const { vertexSize, indexSize } = this.buildData;\r\n\r\n        if (this.packSize === vertexSize)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const { strideFloats, packer, buildData, batches } = this;\r\n        const buffer = this._buffer;\r\n        const index = this._indexBuffer;\r\n        const floatsSize = vertexSize * strideFloats;\r\n\r\n        if (buffer.data.length !== floatsSize)\r\n        {\r\n            const arrBuf = new ArrayBuffer(floatsSize * 4);\r\n\r\n            this._bufferFloats = new Float32Array(arrBuf);\r\n            this._bufferUint = new Uint32Array(arrBuf);\r\n            buffer.data = this._bufferFloats;\r\n        }\r\n        if (index.data.length !== indexSize)\r\n        {\r\n            if (vertexSize > 0xffff && this.pack32index)\r\n            {\r\n                index.data = new Uint32Array(indexSize);\r\n            }\r\n            else\r\n            {\r\n                index.data = new Uint16Array(indexSize);\r\n            }\r\n        }\r\n\r\n        packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index.data as Uint16Array);\r\n\r\n        let j = 0;\r\n\r\n        for (let i = 0; i < this.graphicsData.length; i++)\r\n        {\r\n            const data = this.graphicsData[i];\r\n\r\n            if (data.fillLen)\r\n            {\r\n                while (batches[j].jointEnd <= data.fillStart)\r\n                {\r\n                    j++;\r\n                }\r\n                packer.packInterleavedGeometry(data.fillStart, data.fillLen, data.triangles,\r\n                    batches[j].styleId, batches[j].rgba);\r\n            }\r\n            if (data.strokeLen)\r\n            {\r\n                while (batches[j].jointEnd <= data.strokeStart)\r\n                {\r\n                    j++;\r\n                }\r\n                packer.packInterleavedGeometry(data.strokeStart, data.strokeLen, data.triangles,\r\n                    batches[j].styleId, batches[j].rgba);\r\n            }\r\n        }\r\n\r\n        buffer.update();\r\n        index.update();\r\n        this.packSize = vertexSize;\r\n    }\r\n\r\n    /**\r\n     * Affinity check\r\n     *\r\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\r\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\r\n     */\r\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\r\n    {\r\n        if (!styleA || !styleB)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\r\n        {\r\n            return false;\r\n        }\r\n        // TODO: propagate width for FillStyle\r\n        if ((styleA as LineStyle).width !== (styleB as LineStyle).width)\r\n        {\r\n            return false;\r\n        }\r\n        if ((styleA as LineStyle).scaleMode !== (styleB as LineStyle).scaleMode)\r\n        {\r\n            return false;\r\n        }\r\n        if ((styleA as LineStyle).alignment !== (styleB as LineStyle).alignment)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        const mat1 = styleA.matrix || Matrix.IDENTITY;\r\n        const mat2 = styleB.matrix || Matrix.IDENTITY;\r\n\r\n        return matrixEquals(mat1, mat2);\r\n    }\r\n\r\n    /**\r\n     * Test geometry for batching process.\r\n     *\r\n     * @protected\r\n     */\r\n    protected validateBatching(): boolean\r\n    {\r\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\r\n        {\r\n            const data = this.graphicsData[i];\r\n            const fill = data.fillStyle;\r\n            const line = data.lineStyle;\r\n\r\n            if (fill && !fill.texture.baseTexture.valid) return false;\r\n            if (line && !line.texture.baseTexture.valid) return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Offset the indices so that it works with the batcher.\r\n     *\r\n     * @protected\r\n     */\r\n    protected packBatches(): void\r\n    {\r\n        this.batchDirty++;\r\n        const batches = this.batches;\r\n\r\n        for (let i = 0, l = batches.length; i < l; i++)\r\n        {\r\n            const batch = batches[i];\r\n\r\n            for (let j = 0; j < batch.size; j++)\r\n            {\r\n                const index = batch.start + j;\r\n\r\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected isBatchable(): boolean\r\n    {\r\n        return false;\r\n\r\n        // prevent heavy mesh batching\r\n        // if (this.points.length > 0xffff * 2) {\r\n        //     return false;\r\n        // }\r\n        //\r\n        // const batches = this.batches;\r\n        //\r\n        // for (let i = 0; i < batches.length; i++) {\r\n        //     if ((batches[i].style as LineStyle).native) {\r\n        //         return false;\r\n        //     }\r\n        // }\r\n        //\r\n        // return (this.points.length < SmoothGraphicsGeometry.BATCHABLE_SIZE * 2);\r\n    }\r\n\r\n    /**\r\n     * Converts intermediate batches data to drawCalls.\r\n     *\r\n     * @protected\r\n     */\r\n    protected buildDrawCalls(shaderSettings?: IGraphicsBatchSettings)\r\n    {\r\n        for (let i = 0; i < this.drawCalls.length; i++)\r\n        {\r\n            this.drawCalls[i].clear();\r\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\r\n        }\r\n\r\n        this.drawCalls.length = 0;\r\n\r\n        let currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\r\n\r\n        currentGroup.begin(shaderSettings, null);\r\n\r\n        let index = 0;\r\n\r\n        this.drawCalls.push(currentGroup);\r\n\r\n        for (let i = 0; i < this.batches.length; i++)\r\n        {\r\n            const batchData = this.batches[i];\r\n            const style = batchData.style as LineStyle;\r\n\r\n            if (batchData.attribSize === 0)\r\n            {\r\n                // I don't know how why do we have size=0 sometimes\r\n                continue;\r\n            }\r\n\r\n            let styleId = -1;\r\n            const mat = style.getTextureMatrix();\r\n\r\n            if (currentGroup.check(style.shader))\r\n            {\r\n                styleId = currentGroup.add(style.texture, mat,\r\n                    style.width, style.alignment || 0, style.packLineScale());\r\n            }\r\n            if (styleId < 0)\r\n            {\r\n                currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\r\n                this.drawCalls.push(currentGroup);\r\n                currentGroup.begin(shaderSettings, style.shader);\r\n                currentGroup.start = index;\r\n                styleId = currentGroup.add(style.texture, mat,\r\n                    style.width, style.alignment || 0, style.packLineScale());\r\n            }\r\n            currentGroup.size += batchData.size;\r\n            index += batchData.size;\r\n\r\n            const { color, alpha } = style;\r\n            const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\r\n\r\n            batchData.rgba = premultiplyTint(rgb, alpha);\r\n            batchData.styleId = styleId;\r\n        }\r\n    }\r\n\r\n    protected processHoles(holes: Array<SmoothGraphicsData>): void\r\n    {\r\n        for (let i = 0; i < holes.length; i++)\r\n        {\r\n            const hole = holes[i];\r\n            const command = FILL_COMMANDS[hole.type];\r\n\r\n            command.path(hole, this.buildData);\r\n\r\n            if (hole.matrix)\r\n            {\r\n                this.transformPoints(hole.points, hole.matrix);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the local bounds of the object. Expensive to use performance-wise.\r\n     *\r\n     * @protected\r\n     */\r\n    protected calculateBounds(): void\r\n    {\r\n        const bounds = this._bounds;\r\n        const sequenceBounds = tmpBounds;\r\n        let curMatrix = Matrix.IDENTITY;\r\n\r\n        this._bounds.clear();\r\n        sequenceBounds.clear();\r\n\r\n        for (let i = 0; i < this.graphicsData.length; i++)\r\n        {\r\n            const data = this.graphicsData[i];\r\n            const shape = data.shape;\r\n            const type = data.type;\r\n            const lineStyle = data.lineStyle;\r\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\r\n            let lineWidth = 0.0;\r\n\r\n            if (lineStyle && lineStyle.visible)\r\n            {\r\n                const alignment = lineStyle.alignment;\r\n\r\n                lineWidth = lineStyle.width;\r\n\r\n                if (type === SHAPES.POLY)\r\n                {\r\n                    lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\r\n                }\r\n                else\r\n                {\r\n                    lineWidth = lineWidth * Math.max(0, alignment);\r\n                }\r\n            }\r\n\r\n            if (curMatrix !== nextMatrix)\r\n            {\r\n                if (!sequenceBounds.isEmpty())\r\n                {\r\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\r\n                    sequenceBounds.clear();\r\n                }\r\n                curMatrix = nextMatrix;\r\n            }\r\n\r\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\r\n            {\r\n                const rect = shape as Rectangle | RoundedRectangle;\r\n\r\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\r\n                    lineWidth, lineWidth);\r\n            }\r\n            else if (type === SHAPES.CIRC)\r\n            {\r\n                const circle = shape as Circle;\r\n\r\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\r\n                    circle.radius + lineWidth, circle.radius + lineWidth);\r\n            }\r\n            else if (type === SHAPES.ELIP)\r\n            {\r\n                const ellipse = shape as Ellipse;\r\n\r\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\r\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\r\n            }\r\n            else\r\n            {\r\n                const poly = shape as Polygon;\r\n                // adding directly to the bounds\r\n\r\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\r\n            }\r\n        }\r\n\r\n        if (!sequenceBounds.isEmpty())\r\n        {\r\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\r\n        }\r\n\r\n        bounds.pad(this.boundsPadding, this.boundsPadding);\r\n    }\r\n\r\n    /**\r\n     * Transform points using matrix.\r\n     *\r\n     * @protected\r\n     * @param {number[]} points - Points to transform\r\n     * @param {PIXI.Matrix} matrix - Transform matrix\r\n     */\r\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\r\n    {\r\n        for (let i = 0; i < points.length / 2; i++)\r\n        {\r\n            const x = points[(i * 2)];\r\n            const y = points[(i * 2) + 1];\r\n\r\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\r\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\r\n        }\r\n    }\r\n}\r\n","import { Program, Shader } from '@pixi/core';\r\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\r\n\r\nconst smoothVert = `#version 100\r\nprecision highp float;\r\nconst float FILL = 1.0;\r\nconst float BEVEL = 4.0;\r\nconst float MITER = 8.0;\r\nconst float ROUND = 12.0;\r\nconst float JOINT_CAP_BUTT = 16.0;\r\nconst float JOINT_CAP_SQUARE = 18.0;\r\nconst float JOINT_CAP_ROUND = 20.0;\r\n\r\nconst float FILL_EXPAND = 24.0;\r\n\r\nconst float CAP_BUTT = 1.0;\r\nconst float CAP_SQUARE = 2.0;\r\nconst float CAP_ROUND = 3.0;\r\nconst float CAP_BUTT2 = 4.0;\r\n\r\nconst float MITER_LIMIT = 10.0;\r\n\r\n// === geom ===\r\nattribute vec2 aPrev;\r\nattribute vec2 aPoint1;\r\nattribute vec2 aPoint2;\r\nattribute vec2 aNext;\r\nattribute float aVertexJoint;\r\nattribute float aTravel;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform vec4 tint;\r\n\r\nvarying vec4 vLine1;\r\nvarying vec4 vLine2;\r\nvarying vec4 vArc;\r\nvarying float vType;\r\n\r\nuniform float resolution;\r\nuniform float expand;\r\n\r\n// === style ===\r\nattribute float aStyleId;\r\nattribute vec4 aColor;\r\n\r\nvarying float vTextureId;\r\nvarying vec4 vColor;\r\nvarying vec2 vTextureCoord;\r\nvarying float vTravel;\r\n\r\nuniform vec2 styleLine[%MAX_STYLES%];\r\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\r\nuniform float styleTextureId[%MAX_STYLES%];\r\nuniform vec2 samplerSize[%MAX_TEXTURES%];\r\n\r\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\r\n    float dy, float inner) {\r\n    vec2 bisect = (norm + norm2) / 2.0;\r\n    bisect /= dot(norm, bisect);\r\n    vec2 shift = dy * bisect;\r\n    if (inner > 0.5) {\r\n        if (len < len2) {\r\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\r\n                return dy * norm;\r\n            }\r\n        } else {\r\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\r\n                return dy * norm;\r\n            }\r\n        }\r\n    }\r\n    return dy * bisect;\r\n}\r\n\r\nvoid main(void){\r\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\r\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\r\n\r\n    vec2 xBasis = pointB - pointA;\r\n    float len = length(xBasis);\r\n    vec2 forward = xBasis / len;\r\n    vec2 norm = vec2(forward.y, -forward.x);\r\n\r\n    float type = floor(aVertexJoint / 16.0);\r\n    float vertexNum = aVertexJoint - type * 16.0;\r\n    float dx = 0.0, dy = 1.0;\r\n\r\n    float capType = floor(type / 32.0);\r\n    type -= capType * 32.0;\r\n\r\n    int styleId = int(aStyleId + 0.5);\r\n    float lineWidth = styleLine[styleId].x;\r\n    vTextureId = floor(styleTextureId[styleId] / 4.0);\r\n    float scaleMode = styleTextureId[styleId] - vTextureId * 4.0;\r\n    float avgScale = 1.0;\r\n    if (scaleMode > 2.5) {\r\n        avgScale = length(translationMatrix * vec3(1.0, 0.0, 0.0));\r\n    } else if (scaleMode > 1.5) {\r\n        avgScale = length(translationMatrix * vec3(0.0, 1.0, 0.0));\r\n    } else if (scaleMode > 0.5) {\r\n        vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\r\n        avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\r\n    }\r\n    lineWidth *= 0.5 * avgScale;\r\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\r\n    vTextureCoord = vec2(0.0);\r\n\r\n    vec2 pos;\r\n\r\n    if (capType == CAP_ROUND) {\r\n        vertexNum += 4.0;\r\n        type = JOINT_CAP_ROUND;\r\n        capType = 0.0;\r\n        lineAlignment = -lineAlignment;\r\n    }\r\n\r\n    vLine1 = vec4(0.0, 10.0, 1.0, 0.0);\r\n    vLine2 = vec4(0.0, 10.0, 1.0, 0.0);\r\n    vArc = vec4(0.0);\r\n    if (type == FILL) {\r\n        pos = pointA;\r\n        vType = 0.0;\r\n        vLine2 = vec4(-2.0, -2.0, -2.0, 0.0);\r\n        vec2 vTexturePixel;\r\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\r\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\r\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\r\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\r\n        // expand vertices\r\n        float flags = type - FILL_EXPAND;\r\n        float flag3 = floor(flags / 4.0);\r\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\r\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\r\n\r\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\r\n\r\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\r\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\r\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\r\n\r\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\r\n            n1 = -n1;\r\n            n2 = -n2;\r\n            n3 = -n3;\r\n        }\r\n\r\n        float len2 = length(aNext);\r\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\r\n\r\n        if (vertexNum < 0.5) {\r\n            pos = prev;\r\n\r\n            if (flag1 < 0.5 && flag3 < 0.5) {\r\n                bisect = vec2(0.0);\r\n            } else if (flag1 < 0.5) {\r\n                bisect = vec2(n1.y, -n1.x) + n1 / 8.0;\r\n            } else if (flag3 < 0.5) {\r\n                bisect = vec2(-n3.y, n3.x) + n3 / 8.0;\r\n            }\r\n        } else if (vertexNum < 1.5) {\r\n            pos = pointA;\r\n\r\n            if (flag1 < 0.5 && flag2 < 0.5) {\r\n                bisect = vec2(0.0);\r\n            } else if (flag1 < 0.5) {\r\n                bisect = vec2(-n1.y, n1.x) + n1 / 8.0;\r\n            } else if (flag2 < 0.5) {\r\n                bisect = vec2(n2.y, -n2.x) + n2 / 8.0;\r\n            }\r\n        } else {\r\n            pos = pointB;\r\n\r\n            if (flag2 < 0.5 && flag3 < 0.5) {\r\n                bisect = vec2(0.0);\r\n            } else if (flag2 < 0.5) {\r\n                bisect = vec2(-n2.y, n2.x) + n2 / 8.0;\r\n            } else if (flag3 < 0.5) {\r\n                bisect = vec2(n3.y, -n3.x) + n3 / 8.0;\r\n            }\r\n        }\r\n\r\n        if (length(bisect) > 0.0) {\r\n            bisect = normalize(bisect) * len2;\r\n        }\r\n\r\n        pos += bisect * expand;\r\n\r\n        vLine1 = vec4(16.0, 16.0, 16.0, -1.0);\r\n        if (flag1 > 0.5) {\r\n            vLine1.x = -dot(pos - prev, n1);\r\n        }\r\n        if (flag2 > 0.5) {\r\n            vLine1.y = -dot(pos - pointA, n2);\r\n        }\r\n        if (flag3 > 0.5) {\r\n            vLine1.z = -dot(pos - pointB, n3);\r\n        }\r\n        vLine1.xyz *= resolution;\r\n        vType = 2.0;\r\n    } else if (type >= BEVEL) {\r\n        float dy = lineWidth + expand;\r\n        float shift = lineWidth * lineAlignment;\r\n        float inner = 0.0;\r\n        if (vertexNum >= 1.5) {\r\n            dy = -dy;\r\n            inner = 1.0;\r\n        }\r\n\r\n        vec2 base, next, xBasis2, bisect;\r\n        float flag = 0.0;\r\n        float side2 = 1.0;\r\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\r\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\r\n            base = pointA;\r\n            flag = type - floor(type / 2.0) * 2.0;\r\n            side2 = -1.0;\r\n        } else {\r\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\r\n            base = pointB;\r\n            if (type >= MITER && type < MITER + 3.5) {\r\n                flag = step(MITER + 1.5, type);\r\n                // check miter limit here?\r\n            }\r\n        }\r\n        xBasis2 = next - base;\r\n        float len2 = length(xBasis2);\r\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\r\n        float D = norm.x * norm2.y - norm.y * norm2.x;\r\n        if (D < 0.0) {\r\n            inner = 1.0 - inner;\r\n        }\r\n\r\n        norm2 *= side2;\r\n\r\n        float collinear = step(0.0, dot(norm, norm2));\r\n\r\n        vType = 0.0;\r\n        float dy2 = -1000.0;\r\n\r\n        if (abs(D) < 0.01 && collinear < 0.5) {\r\n            if (type >= ROUND && type < ROUND + 1.5) {\r\n                type = JOINT_CAP_ROUND;\r\n            }\r\n            //TODO: BUTT here too\r\n        }\r\n\r\n        vLine1 = vec4(0.0, lineWidth, max(abs(norm.x), abs(norm.y)), min(abs(norm.x), abs(norm.y)));\r\n        vLine2 = vec4(0.0, lineWidth, max(abs(norm2.x), abs(norm2.y)), min(abs(norm2.x), abs(norm2.y)));\r\n\r\n        if (vertexNum < 3.5) {\r\n            if (abs(D) < 0.01 && collinear < 0.5) {\r\n                pos = (shift + dy) * norm;\r\n            } else {\r\n                if (flag < 0.5 && inner < 0.5) {\r\n                    pos = (shift + dy) * norm;\r\n                } else {\r\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, inner);\r\n                }\r\n            }\r\n            vLine2.y = -1000.0;\r\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\r\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\r\n                vec2 back = -forward;\r\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\r\n                    pos += back * (expand + extra);\r\n                    dy2 = expand;\r\n                } else {\r\n                    dy2 = dot(pos + base - pointA, back) - extra;\r\n                }\r\n            }\r\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\r\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\r\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\r\n                    vLine2.y = dot(pos + base - pointB, forward) - extra;\r\n                } else {\r\n                    pos += forward * (expand + extra);\r\n                    vLine2.y = expand;\r\n                    if (capType >= CAP_BUTT) {\r\n                        dy2 -= expand + extra;\r\n                    }\r\n                }\r\n            }\r\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\r\n            base += shift * norm;\r\n            if (inner > 0.5) {\r\n                dy = -dy;\r\n                inner = 0.0;\r\n            }\r\n            vec2 d2 = abs(dy) * forward;\r\n            if (vertexNum < 4.5) {\r\n                dy = -dy;\r\n                pos = dy * norm;\r\n            } else if (vertexNum < 5.5) {\r\n                pos = dy * norm;\r\n            } else if (vertexNum < 6.5) {\r\n                pos = dy * norm + d2;\r\n                vArc.x = abs(dy);\r\n            } else {\r\n                dy = -dy;\r\n                pos = dy * norm + d2;\r\n                vArc.x = abs(dy);\r\n            }\r\n            vLine2 = vec4(0.0, lineWidth * 2.0 + 10.0, 1.0  , 0.0); // forget about line2 with type=3\r\n            vArc.y = dy;\r\n            vArc.z = 0.0;\r\n            vArc.w = lineWidth;\r\n            vType = 3.0;\r\n        } else if (abs(D) < 0.01 && collinear < 0.5) {\r\n            pos = dy * norm;\r\n        } else {\r\n            if (inner > 0.5) {\r\n                dy = -dy;\r\n                inner = 0.0;\r\n            }\r\n            float side = sign(dy);\r\n            vec2 norm3 = normalize(norm + norm2);\r\n\r\n            if (type >= MITER && type < MITER + 3.5) {\r\n                vec2 farVertex = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\r\n                if (length(farVertex) > abs(shift + dy) * MITER_LIMIT) {\r\n                    type = BEVEL;\r\n                }\r\n            }\r\n\r\n            if (vertexNum < 4.5) {\r\n                pos = doBisect(norm, len, norm2, len2, shift - dy, 1.0);\r\n            } else if (vertexNum < 5.5) {\r\n                pos = (shift + dy) * norm;\r\n            } else if (vertexNum > 7.5) {\r\n                pos = (shift + dy) * norm2;\r\n            } else {\r\n                if (type >= ROUND && type < ROUND + 1.5) {\r\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\r\n                    float d2 = abs(shift + dy);\r\n                    if (length(pos) > abs(shift + dy) * 1.5) {\r\n                        if (vertexNum < 6.5) {\r\n                            pos.x = (shift + dy) * norm.x - d2 * norm.y;\r\n                            pos.y = (shift + dy) * norm.y + d2 * norm.x;\r\n                        } else {\r\n                            pos.x = (shift + dy) * norm2.x + d2 * norm2.y;\r\n                            pos.y = (shift + dy) * norm2.y - d2 * norm2.x;\r\n                        }\r\n                    }\r\n                } else if (type >= MITER && type < MITER + 3.5) {\r\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0); //farVertex\r\n                } else if (type >= BEVEL && type < BEVEL + 1.5) {\r\n                    float d2 = side / resolution;\r\n                    if (vertexNum < 6.5) {\r\n                        pos = (shift + dy) * norm + d2 * norm3;\r\n                    } else {\r\n                        pos = (shift + dy) * norm2 + d2 * norm3;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (type >= ROUND && type < ROUND + 1.5) {\r\n                vArc.x = side * dot(pos, norm3);\r\n                vArc.y = pos.x * norm3.y - pos.y * norm3.x;\r\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift);\r\n                vArc.w = lineWidth + side * shift;\r\n                vType = 3.0;\r\n            } else if (type >= MITER && type < MITER + 3.5) {\r\n                vType = 1.0;\r\n            } else if (type >= BEVEL && type < BEVEL + 1.5) {\r\n                vType = 4.0;\r\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift) - side * dot(pos, norm3);\r\n            }\r\n\r\n            dy = side * (dot(pos, norm) - shift);\r\n            dy2 = side * (dot(pos, norm2) - shift);\r\n        }\r\n\r\n        pos += base;\r\n        vLine1.xy = vec2(dy, vLine1.y) * resolution;\r\n        vLine2.xy = vec2(dy2, vLine2.y) * resolution;\r\n        vArc = vArc * resolution;\r\n        vTravel = aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x));\r\n    }\r\n\r\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vColor = aColor * tint;\r\n}`;\r\n\r\nconst precision = `#version 100\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n`;\r\n\r\nconst smoothFrag = `%PRECISION%\r\nvarying vec4 vColor;\r\nvarying vec4 vLine1;\r\nvarying vec4 vLine2;\r\nvarying vec4 vArc;\r\nvarying float vType;\r\nvarying float vTextureId;\r\nvarying vec2 vTextureCoord;\r\nvarying float vTravel;\r\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\r\n\r\n%PIXEL_LINE%\r\n\r\nvoid main(void){\r\n    %PIXEL_COVERAGE%\r\n\r\n    vec4 texColor;\r\n    float textureId = floor(vTextureId+0.5);\r\n    %FOR_LOOP%\r\n\r\n    gl_FragColor = vColor * texColor * alpha;\r\n}\r\n`;\r\n\r\nconst pixelLineFunc = [`\r\nfloat pixelLine(float x, float A, float B) {\r\n    return clamp(x + 0.5, 0.0, 1.0);\r\n}\r\n`, `\r\nfloat pixelLine(float x, float A, float B) {\r\n    float y = abs(x), s = sign(x);\r\n    if (y * 2.0 < A - B) {\r\n        return 0.5 + s * y / A;\r\n    }\r\n    y -= (A - B) * 0.5;\r\n    y = max(1.0 - y / B, 0.0);\r\n    return (1.0 + s * (1.0 - y * y)) * 0.5;\r\n    //return clamp(x + 0.5, 0.0, 1.0);\r\n}\r\n`];\r\n\r\nconst pixelCoverage = `float alpha = 1.0;\r\nif (vType < 0.5) {\r\n    float left = pixelLine(-vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float right = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float near = vLine2.x - 0.5;\r\n    float far = min(vLine2.x + 0.5, 0.0);\r\n    float top = vLine2.y - 0.5;\r\n    float bottom = min(vLine2.y + 0.5, 0.0);\r\n    alpha = (right - left) * max(bottom - top, 0.0) * max(far - near, 0.0);\r\n} else if (vType < 1.5) {\r\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    alpha = a2 * b2 - a1 * b1;\r\n} else if (vType < 2.5) {\r\n    alpha *= max(min(vLine1.x + 0.5, 1.0), 0.0);\r\n    alpha *= max(min(vLine1.y + 0.5, 1.0), 0.0);\r\n    alpha *= max(min(vLine1.z + 0.5, 1.0), 0.0);\r\n} else if (vType < 3.5) {\r\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float alpha_miter = a2 * b2 - a1 * b1;\r\n    float alpha_plane = clamp(vArc.z - vArc.x + 0.5, 0.0, 1.0);\r\n    float d = length(vArc.xy);\r\n    float circle_hor = max(min(vArc.w, d + 0.5) - max(-vArc.w, d - 0.5), 0.0);\r\n    float circle_vert = min(vArc.w * 2.0, 1.0);\r\n    float alpha_circle = circle_hor * circle_vert;\r\n    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\r\n} else {\r\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    alpha = a2 * b2 - a1 * b1;\r\n    alpha *= clamp(vArc.z + 0.5, 0.0, 1.0);\r\n}\r\n`;\r\n\r\nexport class SmoothGraphicsProgram extends Program\r\n{\r\n    settings: IGraphicsBatchSettings;\r\n\r\n    constructor(settings: IGraphicsBatchSettings,\r\n        vert = smoothVert,\r\n        frag = smoothFrag,\r\n        _uniforms = {})\r\n    {\r\n        const { maxStyles, maxTextures, pixelLine } = settings;\r\n\r\n        vert = vert.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\r\n            .replace(/%MAX_STYLES%/gi, `${maxStyles}`);\r\n        frag = frag.replace(/%PRECISION%/gi, precision)\r\n            .replace(/%PIXEL_LINE%/gi, pixelLineFunc[pixelLine])\r\n            .replace(/%PIXEL_COVERAGE%/gi, pixelCoverage)\r\n            .replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            .replace(/%FOR_LOOP%/gi, SmoothGraphicsShader.generateSampleSrc(maxTextures));\r\n\r\n        super(vert, frag);\r\n        this.settings = settings;\r\n    }\r\n}\r\n\r\nexport class SmoothGraphicsShader extends Shader\r\n{\r\n    settings: IGraphicsBatchSettings;\r\n\r\n    constructor(settings: IGraphicsBatchSettings, prog = new SmoothGraphicsProgram(settings), uniforms = {})\r\n    {\r\n        const { maxStyles, maxTextures } = settings;\r\n        const sampleValues = new Int32Array(maxTextures);\r\n\r\n        for (let i = 0; i < maxTextures; i++)\r\n        {\r\n            sampleValues[i] = i;\r\n        }\r\n        super(prog, (Object as any).assign(uniforms, {\r\n            styleMatrix: new Float32Array(6 * maxStyles),\r\n            styleTextureId: new Float32Array(maxStyles),\r\n            styleLine: new Float32Array(2 * maxStyles),\r\n            samplerSize: new Float32Array(2 * maxTextures),\r\n            uSamplers: sampleValues,\r\n            tint: new Float32Array([1, 1, 1, 1]),\r\n            resolution: 1,\r\n            expand: 1,\r\n        }));\r\n        this.settings = settings;\r\n    }\r\n\r\n    static generateSampleSrc(maxTextures: number): string\r\n    {\r\n        let src = '';\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        for (let i = 0; i < maxTextures; i++)\r\n        {\r\n            if (i > 0)\r\n            {\r\n                src += '\\nelse ';\r\n            }\r\n\r\n            if (i < maxTextures - 1)\r\n            {\r\n                src += `if(textureId < ${i}.5)`;\r\n            }\r\n\r\n            src += '\\n{';\r\n            src += `\\n\\ttexColor = texture2D(uSamplers[${i}], vTextureCoord);`;\r\n            src += '\\n}';\r\n        }\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        return src;\r\n    }\r\n}\r\n","import { LINE_SCALE_MODE } from './core/LineStyle';\r\n\r\nexport interface ISettings {\r\n    LINE_SCALE_MODE: string;\r\n    SHADER_MAX_STYLES: number;\r\n    SHADER_MAX_TEXTURES: number;\r\n    PIXEL_LINE: number;\r\n}\r\n\r\nexport const settings: ISettings = {\r\n    LINE_SCALE_MODE: LINE_SCALE_MODE.NORMAL,\r\n    SHADER_MAX_STYLES: 24,\r\n    SHADER_MAX_TEXTURES: 4,\r\n    PIXEL_LINE: 0,\r\n};\r\n","import {\r\n    Circle,\r\n    Ellipse,\r\n    PI_2,\r\n    Point,\r\n    Polygon,\r\n    Rectangle,\r\n    RoundedRectangle,\r\n    Matrix,\r\n    SHAPES,\r\n} from '@pixi/math';\r\n\r\nimport { Texture, State, Renderer, Shader } from '@pixi/core';\r\nimport { graphicsUtils, LINE_JOIN, LINE_CAP, Graphics } from '@pixi/graphics';\r\nimport { hex2rgb } from '@pixi/utils';\r\nimport { SmoothGraphicsGeometry } from './SmoothGraphicsGeometry';\r\nimport { BLEND_MODES, DRAW_MODES } from '@pixi/constants';\r\nimport { Container } from '@pixi/display';\r\n\r\nimport type { IShape, IPointData } from '@pixi/math';\r\nimport type { IDestroyOptions } from '@pixi/display';\r\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\r\nimport { FillStyle } from './core/FillStyle';\r\nimport { LINE_SCALE_MODE, LineStyle } from './core/LineStyle';\r\nimport { SmoothGraphicsShader } from './SmoothShader';\r\nimport { settings } from './settings';\r\n\r\nconst { BezierUtils, QuadraticUtils, ArcUtils } = graphicsUtils;\r\n\r\nconst temp = new Float32Array(3);\r\n// a default shaders map used by graphics..\r\nconst DEFAULT_SHADERS: { [key: string]: Shader } = {};\r\n\r\nexport interface IFillStyleOptions {\r\n    color?: number;\r\n    alpha?: number;\r\n    texture?: Texture;\r\n    matrix?: Matrix;\r\n    smooth?: boolean;\r\n    shader?: Shader;\r\n}\r\n\r\nexport interface ILineStyleOptions extends IFillStyleOptions {\r\n    width?: number;\r\n    alignment?: number;\r\n    scaleMode?: LINE_SCALE_MODE;\r\n    cap?: LINE_CAP;\r\n    join?: LINE_JOIN;\r\n    miterLimit?: number;\r\n}\r\n\r\nexport class SmoothGraphics extends Container\r\n{\r\n    static _TEMP_POINT = new Point();\r\n\r\n    public shader: Shader;\r\n    public shaderSettings: IGraphicsBatchSettings;\r\n    public pluginName: string;\r\n    public currentPath: Polygon;\r\n\r\n    protected batches: Array<any>;\r\n    protected batchTint: number;\r\n    protected batchDirty: number;\r\n    protected vertexData: Float32Array;\r\n\r\n    protected _fillStyle: FillStyle;\r\n    protected _lineStyle: LineStyle;\r\n    protected _matrix: Matrix;\r\n    protected _holeMode: boolean;\r\n    protected _transformID: number;\r\n    protected _tint: number;\r\n\r\n    private state: State;\r\n    private _geometry: SmoothGraphicsGeometry;\r\n\r\n    public get geometry(): SmoothGraphicsGeometry\r\n    {\r\n        return this._geometry;\r\n    }\r\n\r\n    constructor(geometry: SmoothGraphicsGeometry = null)\r\n    {\r\n        super();\r\n\r\n        this._geometry = geometry || new SmoothGraphicsGeometry();\r\n        this._geometry.refCount++;\r\n\r\n        this.shader = null;\r\n\r\n        this.shaderSettings = {\r\n            maxStyles: settings.SHADER_MAX_STYLES,\r\n            maxTextures: settings.SHADER_MAX_TEXTURES,\r\n            pixelLine: settings.PIXEL_LINE,\r\n        };\r\n\r\n        this.state = State.for2d();\r\n\r\n        this._fillStyle = new FillStyle();\r\n\r\n        this._lineStyle = new LineStyle();\r\n\r\n        this._matrix = null;\r\n\r\n        this._holeMode = false;\r\n\r\n        this.currentPath = null;\r\n\r\n        this.batches = [];\r\n\r\n        this.batchTint = -1;\r\n\r\n        this.batchDirty = -1;\r\n\r\n        this.vertexData = null;\r\n\r\n        this.pluginName = 'smooth';\r\n\r\n        this._transformID = -1;\r\n\r\n        // Set default\r\n        this.tint = 0xFFFFFF;\r\n        this.blendMode = BLEND_MODES.NORMAL;\r\n    }\r\n\r\n    public clone(): SmoothGraphics\r\n    {\r\n        this.finishPoly();\r\n\r\n        return new SmoothGraphics(this._geometry);\r\n    }\r\n\r\n    public set blendMode(value: BLEND_MODES)\r\n    {\r\n        this.state.blendMode = value;\r\n    }\r\n\r\n    public get blendMode(): BLEND_MODES\r\n    {\r\n        return this.state.blendMode;\r\n    }\r\n\r\n    public get tint(): number\r\n    {\r\n        return this._tint;\r\n    }\r\n\r\n    public set tint(value: number)\r\n    {\r\n        this._tint = value;\r\n    }\r\n\r\n    public get fill(): FillStyle\r\n    {\r\n        return this._fillStyle;\r\n    }\r\n\r\n    public get line(): LineStyle\r\n    {\r\n        return this._lineStyle;\r\n    }\r\n\r\n    public lineStyle(width: number, color?: number, alpha?: number, alignment?: number, scaleMode?: LINE_SCALE_MODE): this;\r\n\r\n    public lineStyle(options?: ILineStyleOptions): this;\r\n\r\n    public lineStyle(options: ILineStyleOptions | number = null,\r\n        color = 0x0, alpha = 1, alignment = 0.5, scaleMode = settings.LINE_SCALE_MODE): this\r\n    {\r\n        // Support non-object params: (width, color, alpha, alignment, native)\r\n        if (typeof options === 'number')\r\n        {\r\n            if (typeof scaleMode === 'boolean')\r\n            {\r\n                scaleMode = scaleMode ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\r\n            }\r\n            options = { width: options, color, alpha, alignment, scaleMode } as ILineStyleOptions;\r\n        }\r\n        else\r\n        {\r\n            const native: boolean = (options as any).native;\r\n\r\n            if (native !== undefined)\r\n            {\r\n                options.scaleMode = native ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\r\n            }\r\n        }\r\n\r\n        return this.lineTextureStyle(options);\r\n    }\r\n\r\n    public lineTextureStyle(options: ILineStyleOptions): this\r\n    {\r\n        // Apply defaults\r\n        options = Object.assign({\r\n            width: 0,\r\n            texture: Texture.WHITE,\r\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\r\n            alpha: 1,\r\n            matrix: null,\r\n            alignment: 0.5,\r\n            native: false,\r\n            cap: LINE_CAP.BUTT,\r\n            join: LINE_JOIN.MITER,\r\n            miterLimit: 10,\r\n            shader: null,\r\n            scaleMode: settings.LINE_SCALE_MODE,\r\n        }, options);\r\n\r\n        if (this.currentPath)\r\n        {\r\n            this.startPoly();\r\n        }\r\n\r\n        const visible = options.width > 0 && options.alpha > 0;\r\n\r\n        if (!visible)\r\n        {\r\n            this._lineStyle.reset();\r\n        }\r\n        else\r\n        {\r\n            if (options.matrix)\r\n            {\r\n                options.matrix = options.matrix.clone();\r\n                options.matrix.invert();\r\n            }\r\n\r\n            Object.assign(this._lineStyle, { visible }, options);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected startPoly(): void\r\n    {\r\n        if (this.currentPath)\r\n        {\r\n            const points = this.currentPath.points;\r\n            const len = this.currentPath.points.length;\r\n\r\n            if (len > 2)\r\n            {\r\n                this.drawShape(this.currentPath);\r\n                this.currentPath = new Polygon();\r\n                this.currentPath.closeStroke = false;\r\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.currentPath = new Polygon();\r\n            this.currentPath.closeStroke = false;\r\n        }\r\n    }\r\n\r\n    finishPoly(): void\r\n    {\r\n        if (this.currentPath)\r\n        {\r\n            if (this.currentPath.points.length > 2)\r\n            {\r\n                this.drawShape(this.currentPath);\r\n                this.currentPath = null;\r\n            }\r\n            else\r\n            {\r\n                this.currentPath.points.length = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    public moveTo(x: number, y: number): this\r\n    {\r\n        this.startPoly();\r\n        this.currentPath.points[0] = x;\r\n        this.currentPath.points[1] = y;\r\n\r\n        return this;\r\n    }\r\n\r\n    public lineTo(x: number, y: number): this\r\n    {\r\n        if (!this.currentPath)\r\n        {\r\n            this.moveTo(0, 0);\r\n        }\r\n\r\n        // remove duplicates..\r\n        const points = this.currentPath.points;\r\n        const fromX = points[points.length - 2];\r\n        const fromY = points[points.length - 1];\r\n\r\n        if (fromX !== x || fromY !== y)\r\n        {\r\n            points.push(x, y);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _initCurve(x = 0, y = 0): void\r\n    {\r\n        if (this.currentPath)\r\n        {\r\n            if (this.currentPath.points.length === 0)\r\n            {\r\n                this.currentPath.points = [x, y];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.moveTo(x, y);\r\n        }\r\n    }\r\n\r\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\r\n    {\r\n        this._initCurve();\r\n\r\n        const points = this.currentPath.points;\r\n\r\n        if (points.length === 0)\r\n        {\r\n            this.moveTo(0, 0);\r\n        }\r\n\r\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\r\n\r\n        return this;\r\n    }\r\n\r\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\r\n    {\r\n        this._initCurve();\r\n\r\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\r\n\r\n        return this;\r\n    }\r\n\r\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\r\n    {\r\n        this._initCurve(x1, y1);\r\n\r\n        const points = this.currentPath.points;\r\n\r\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\r\n\r\n        if (result)\r\n        {\r\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\r\n\r\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\r\n    {\r\n        if (startAngle === endAngle)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (!anticlockwise && endAngle <= startAngle)\r\n        {\r\n            endAngle += PI_2;\r\n        }\r\n        else if (anticlockwise && startAngle <= endAngle)\r\n        {\r\n            startAngle += PI_2;\r\n        }\r\n\r\n        const sweep = endAngle - startAngle;\r\n\r\n        if (sweep === 0)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        const startX = cx + (Math.cos(startAngle) * radius);\r\n        const startY = cy + (Math.sin(startAngle) * radius);\r\n        const eps = this._geometry.closePointEps;\r\n\r\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\r\n        let points = this.currentPath ? this.currentPath.points : null;\r\n\r\n        if (points)\r\n        {\r\n            // TODO: make a better fix.\r\n\r\n            // We check how far our start is from the last existing point\r\n            const xDiff = Math.abs(points[points.length - 2] - startX);\r\n            const yDiff = Math.abs(points[points.length - 1] - startY);\r\n\r\n            if (xDiff < eps && yDiff < eps)\r\n            {\r\n                // If the point is very close, we don't add it, since this would lead to artifacts\r\n                // during tessellation due to floating point imprecision.\r\n            }\r\n            else\r\n            {\r\n                points.push(startX, startY);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.moveTo(startX, startY);\r\n            points = this.currentPath.points;\r\n        }\r\n\r\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\r\n\r\n        return this;\r\n    }\r\n\r\n    public beginFill(color = 0, alpha = 1, smooth = false): this\r\n    {\r\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha, smooth });\r\n    }\r\n\r\n    beginTextureFill(options?: IFillStyleOptions): this\r\n    {\r\n        // Apply defaults\r\n        options = Object.assign({\r\n            texture: Texture.WHITE,\r\n            color: 0xFFFFFF,\r\n            alpha: 1,\r\n            matrix: null,\r\n            smooth: false,\r\n        }, options) as IFillStyleOptions;\r\n\r\n        if (this.currentPath)\r\n        {\r\n            this.startPoly();\r\n        }\r\n\r\n        const visible = options.alpha > 0;\r\n\r\n        if (!visible)\r\n        {\r\n            this._fillStyle.reset();\r\n        }\r\n        else\r\n        {\r\n            if (options.matrix)\r\n            {\r\n                options.matrix = options.matrix.clone();\r\n                options.matrix.invert();\r\n            }\r\n\r\n            Object.assign(this._fillStyle, { visible }, options);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public endFill(): this\r\n    {\r\n        this.finishPoly();\r\n\r\n        this._fillStyle.reset();\r\n\r\n        return this;\r\n    }\r\n\r\n    public drawRect(x: number, y: number, width: number, height: number): this\r\n    {\r\n        return this.drawShape(new Rectangle(x, y, width, height));\r\n    }\r\n\r\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\r\n    {\r\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\r\n    }\r\n\r\n    public drawCircle(x: number, y: number, radius: number): this\r\n    {\r\n        return this.drawShape(new Circle(x, y, radius));\r\n    }\r\n\r\n    public drawEllipse(x: number, y: number, width: number, height: number): this\r\n    {\r\n        return this.drawShape(new Ellipse(x, y, width, height));\r\n    }\r\n\r\n    public drawPolygon(...path: Array<number> | Array<Point>): this\r\n    public drawPolygon(path: Array<number> | Array<Point> | Polygon): this\r\n\r\n    public drawPolygon(...path: any[]): this\r\n    {\r\n        let points: Array<number> | Array<Point>;\r\n        let closeStroke = true;// !!this._fillStyle;\r\n\r\n        const poly = path[0] as Polygon;\r\n\r\n        // check if data has points..\r\n        if (poly.points)\r\n        {\r\n            closeStroke = poly.closeStroke;\r\n            points = poly.points;\r\n        }\r\n        else if (Array.isArray(path[0]))\r\n        {\r\n            points = path[0];\r\n        }\r\n        else\r\n        {\r\n            points = path;\r\n        }\r\n\r\n        const shape = new Polygon(points);\r\n\r\n        shape.closeStroke = closeStroke;\r\n\r\n        this.drawShape(shape);\r\n\r\n        return this;\r\n    }\r\n\r\n    public drawShape(shape: IShape): this\r\n    {\r\n        if (!this._holeMode)\r\n        {\r\n            this._geometry.drawShape(\r\n                shape,\r\n                this._fillStyle.clone(),\r\n                this._lineStyle.clone(),\r\n                this._matrix\r\n            );\r\n        }\r\n        else\r\n        {\r\n            this._geometry.drawHole(shape, this._matrix);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public clear(): this\r\n    {\r\n        this._geometry.clear();\r\n        this._lineStyle.reset();\r\n        this._fillStyle.reset();\r\n\r\n        this._boundsID++;\r\n        this._matrix = null;\r\n        this._holeMode = false;\r\n        this.currentPath = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    public isFastRect(): boolean\r\n    {\r\n        const data = this._geometry.graphicsData;\r\n\r\n        return data.length === 1\r\n            && data[0].shape.type === SHAPES.RECT\r\n            && !data[0].matrix\r\n            && !data[0].holes.length\r\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\r\n    }\r\n\r\n    protected _renderCanvas(renderer: any): void\r\n    {\r\n        (Graphics.prototype as any)._renderCanvas.call(this, renderer);\r\n    }\r\n\r\n    protected _render(renderer: Renderer): void\r\n    {\r\n        this.finishPoly();\r\n\r\n        const geometry = this._geometry;\r\n        const hasuint32 = renderer.context.supports.uint32Indices;\r\n        // batch part..\r\n        // batch it!\r\n\r\n        geometry.checkInstancing(renderer.geometry.hasInstance, hasuint32);\r\n\r\n        geometry.updateBatches(this.shaderSettings);\r\n\r\n        if (geometry.batchable)\r\n        {\r\n            if (this.batchDirty !== geometry.batchDirty)\r\n            {\r\n                this._populateBatches();\r\n            }\r\n\r\n            this._renderBatched(renderer);\r\n        }\r\n        else\r\n        {\r\n            // no batching...\r\n            renderer.batch.flush();\r\n\r\n            this._renderDirect(renderer);\r\n        }\r\n    }\r\n\r\n    protected _populateBatches(): void\r\n    {\r\n        const geometry = this._geometry;\r\n        const blendMode = this.blendMode;\r\n        const len = geometry.batches.length;\r\n\r\n        this.batchTint = -1;\r\n        this._transformID = -1;\r\n        this.batchDirty = geometry.batchDirty;\r\n        this.batches.length = len;\r\n\r\n        this.vertexData = new Float32Array(geometry.points);\r\n\r\n        for (let i = 0; i < len; i++)\r\n        {\r\n            const gI = geometry.batches[i];\r\n            const color = gI.style.color;\r\n            const vertexData = new Float32Array(this.vertexData.buffer,\r\n                gI.attribStart * 4 * 2,\r\n                gI.attribSize * 2);\r\n\r\n            // const uvs = new Float32Array(geometry.uvsFloat32.buffer,\r\n            //     gI.attribStart * 4 * 2,\r\n            //     gI.attribSize * 2);\r\n\r\n            // const indices = new Uint16Array(geometry.indicesUint16.buffer,\r\n            //     gI.start * 2,\r\n            //     gI.size);\r\n\r\n            const batch = {\r\n                vertexData,\r\n                blendMode,\r\n                // indices,\r\n                // uvs,\r\n                _batchRGB: hex2rgb(color) as Array<number>,\r\n                _tintRGB: color,\r\n                _texture: gI.style.texture,\r\n                alpha: gI.style.alpha,\r\n                worldAlpha: 1\r\n            };\r\n\r\n            this.batches[i] = batch;\r\n        }\r\n    }\r\n\r\n    protected _renderBatched(renderer: Renderer): void\r\n    {\r\n        if (!this.batches.length)\r\n        {\r\n            return;\r\n        }\r\n\r\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\r\n\r\n        this.calculateVertices();\r\n        this.calculateTints();\r\n\r\n        for (let i = 0, l = this.batches.length; i < l; i++)\r\n        {\r\n            const batch = this.batches[i];\r\n\r\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\r\n\r\n            renderer.plugins[this.pluginName].render(batch);\r\n        }\r\n    }\r\n\r\n    protected _renderDirect(renderer: Renderer): void\r\n    {\r\n        const directShader = this._resolveDirectShader(renderer);\r\n        let shader: Shader = directShader;\r\n\r\n        const geometry = this._geometry;\r\n        const tint = this.tint;\r\n        const worldAlpha = this.worldAlpha;\r\n        const uniforms = shader.uniforms;\r\n        const drawCalls = geometry.drawCalls;\r\n\r\n        // lets set the transfomr\r\n        uniforms.translationMatrix = this.transform.worldTransform;\r\n\r\n        // and then lets set the tint..\r\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\r\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\r\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\r\n        uniforms.tint[3] = worldAlpha;\r\n\r\n        uniforms.resolution = renderer.renderTexture.current\r\n            ? renderer.renderTexture.current.resolution : renderer.resolution;\r\n\r\n        const projTrans = renderer.projection.transform;\r\n\r\n        if (projTrans)\r\n        {\r\n            // only uniform scale is supported!\r\n            const scale = Math.sqrt(projTrans.a * projTrans.a + projTrans.b * projTrans.b);\r\n\r\n            uniforms.resolution *= scale;\r\n        }\r\n\r\n        uniforms.expand = (renderer.options.antialias ? 2 : 1) / uniforms.resolution;\r\n\r\n        // the first draw call, we can set the uniforms of the shader directly here.\r\n\r\n        // this means that we can tack advantage of the sync function of pixi!\r\n        // bind and sync uniforms..\r\n        // there is a way to optimise this..\r\n        renderer.shader.bind(shader);\r\n        renderer.geometry.bind(geometry, shader);\r\n\r\n        // set state..\r\n        renderer.state.set(this.state);\r\n\r\n        shader = null;\r\n        // then render the rest of them...\r\n        for (let i = 0, l = drawCalls.length; i < l; i++)\r\n        {\r\n            // TODO: refactor it to another class, that fills uniforms of this shader\r\n            const drawCall = geometry.drawCalls[i];\r\n\r\n            const shaderChange = shader !== drawCall.shader;\r\n\r\n            if (shaderChange)\r\n            {\r\n                shader = drawCall.shader;\r\n                if (shader)\r\n                {\r\n                    shader.uniforms.translationMatrix = this.transform.worldTransform;\r\n                    if (shader.uniforms.tint)\r\n                    {\r\n                        shader.uniforms.tint[0] = uniforms.tint[0];\r\n                        shader.uniforms.tint[1] = uniforms.tint[1];\r\n                        shader.uniforms.tint[2] = uniforms.tint[2];\r\n                        shader.uniforms.tint[3] = uniforms.tint[3];\r\n                    }\r\n                }\r\n            }\r\n\r\n            const { texArray, styleArray, size, start } = drawCall;\r\n            const groupTextureCount = texArray.count;\r\n            const shaderHere = shader || directShader;\r\n\r\n            const texs = shaderHere.uniforms.styleTextureId;\r\n            const mats = shaderHere.uniforms.styleMatrix;\r\n            const lines = shaderHere.uniforms.styleLine;\r\n\r\n            for (let i = 0; i < styleArray.count; i++)\r\n            {\r\n                texs[i] = styleArray.textureIds[i];\r\n                lines[i * 2] = styleArray.lines[i * 2];\r\n                lines[(i * 2) + 1] = styleArray.lines[(i * 2) + 1];\r\n                const m = styleArray.matrices[i];\r\n\r\n                mats[i * 6] = m.a;\r\n                mats[(i * 6) + 1] = m.c;\r\n                mats[(i * 6) + 2] = m.tx;\r\n                mats[(i * 6) + 3] = m.b;\r\n                mats[(i * 6) + 4] = m.d;\r\n                mats[(i * 6) + 5] = m.ty;\r\n            }\r\n            const sizes = shaderHere.uniforms.samplerSize;\r\n\r\n            for (let i = 0; i < groupTextureCount; i++)\r\n            {\r\n                sizes[i * 2] = texArray.elements[i].width;\r\n                sizes[(i * 2) + 1] = texArray.elements[i].height;\r\n            }\r\n\r\n            renderer.shader.bind(shaderHere);\r\n            if (shaderChange)\r\n            {\r\n                renderer.geometry.bind(geometry);\r\n            }\r\n\r\n            // TODO: bind styles!\r\n            for (let j = 0; j < groupTextureCount; j++)\r\n            {\r\n                renderer.texture.bind(texArray.elements[j], j);\r\n            }\r\n\r\n            // bind the geometry...\r\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES, size, start);\r\n        }\r\n    }\r\n\r\n    protected _resolveDirectShader(_renderer: Renderer): Shader\r\n    {\r\n        let shader = this.shader;\r\n\r\n        const pluginName = this.pluginName;\r\n\r\n        if (!shader)\r\n        {\r\n            if (!DEFAULT_SHADERS[pluginName])\r\n            {\r\n                DEFAULT_SHADERS[pluginName] = new SmoothGraphicsShader(this.shaderSettings);\r\n            }\r\n            shader = DEFAULT_SHADERS[pluginName];\r\n        }\r\n\r\n        return shader;\r\n    }\r\n\r\n    protected _calculateBounds(): void\r\n    {\r\n        this.finishPoly();\r\n\r\n        const geometry = this._geometry;\r\n\r\n        // skipping when graphics is empty, like a container\r\n        if (!geometry.graphicsData.length)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const { minX, minY, maxX, maxY } = geometry.bounds;\r\n\r\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\r\n    }\r\n\r\n    public containsPoint(point: IPointData): boolean\r\n    {\r\n        this.worldTransform.applyInverse(point, SmoothGraphics._TEMP_POINT);\r\n\r\n        return this._geometry.containsPoint(SmoothGraphics._TEMP_POINT);\r\n    }\r\n\r\n    protected calculateTints(): void\r\n    {\r\n        if (this.batchTint !== this.tint)\r\n        {\r\n            this.batchTint = this.tint;\r\n\r\n            const tintRGB = hex2rgb(this.tint, temp);\r\n\r\n            for (let i = 0; i < this.batches.length; i++)\r\n            {\r\n                const batch = this.batches[i];\r\n\r\n                const batchTint = batch._batchRGB;\r\n\r\n                const r = (tintRGB[0] * batchTint[0]) * 255;\r\n                const g = (tintRGB[1] * batchTint[1]) * 255;\r\n                const b = (tintRGB[2] * batchTint[2]) * 255;\r\n\r\n                // TODO Ivan, can this be done in one go?\r\n                const color = (r << 16) + (g << 8) + (b | 0);\r\n\r\n                batch._tintRGB = (color >> 16)\r\n                    + (color & 0xff00)\r\n                    + ((color & 0xff) << 16);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected calculateVertices(): void\r\n    {\r\n        const wtID = this.transform._worldID;\r\n\r\n        if (this._transformID === wtID)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._transformID = wtID;\r\n\r\n        const wt = this.transform.worldTransform;\r\n        const a = wt.a;\r\n        const b = wt.b;\r\n        const c = wt.c;\r\n        const d = wt.d;\r\n        const tx = wt.tx;\r\n        const ty = wt.ty;\r\n\r\n        const data = this._geometry.points;// batch.vertexDataOriginal;\r\n        const vertexData = this.vertexData;\r\n\r\n        let count = 0;\r\n\r\n        for (let i = 0; i < data.length; i += 2)\r\n        {\r\n            const x = data[i];\r\n            const y = data[i + 1];\r\n\r\n            vertexData[count++] = (a * x) + (c * y) + tx;\r\n            vertexData[count++] = (d * y) + (b * x) + ty;\r\n        }\r\n    }\r\n\r\n    public closePath(): this\r\n    {\r\n        const currentPath = this.currentPath;\r\n\r\n        if (currentPath)\r\n        {\r\n            // we don't need to add extra point in the end because buildLine will take care of that\r\n            currentPath.closeStroke = true;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public setMatrix(matrix: Matrix): this\r\n    {\r\n        this._matrix = matrix;\r\n\r\n        return this;\r\n    }\r\n\r\n    public beginHole(): this\r\n    {\r\n        this.finishPoly();\r\n        this._holeMode = true;\r\n\r\n        return this;\r\n    }\r\n\r\n    public endHole(): this\r\n    {\r\n        this.finishPoly();\r\n        this._holeMode = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    public destroy(options?: IDestroyOptions | boolean): void\r\n    {\r\n        this._geometry.refCount--;\r\n        if (this._geometry.refCount === 0)\r\n        {\r\n            this._geometry.dispose();\r\n        }\r\n\r\n        this._matrix = null;\r\n        this.currentPath = null;\r\n        this._lineStyle.destroy();\r\n        this._lineStyle = null;\r\n        this._fillStyle.destroy();\r\n        this._fillStyle = null;\r\n        this._geometry = null;\r\n        this.shader = null;\r\n        this.vertexData = null;\r\n        this.batches.length = 0;\r\n        this.batches = null;\r\n\r\n        super.destroy(options);\r\n    }\r\n}\r\n","import { SmoothGraphicsProgram, SmoothGraphicsShader } from './SmoothShader';\r\n\r\nconst dashFrag = `%PRECISION%\r\nvarying vec4 vColor;\r\nvarying vec4 vLine1;\r\nvarying vec4 vLine2;\r\nvarying vec4 vArc;\r\nvarying float vType;\r\nvarying float vTextureId;\r\nvarying vec2 vTextureCoord;\r\nvarying float vTravel;\r\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\r\nuniform float dash;\r\nuniform float gap;\r\n\r\n%PIXEL_LINE%\r\n\r\nvoid main(void){\r\n    %PIXEL_COVERAGE%\r\n\r\n    if (dash + gap > 1.0)\r\n    {\r\n        float travel = mod(vTravel + gap * 0.5, dash + gap) - (gap * 0.5);\r\n        float left = max(travel - 0.5, -0.5);\r\n        float right = min(travel + 0.5, gap + 0.5);\r\n        alpha *= max(0.0, right - left);\r\n    }\r\n\r\n    vec4 texColor;\r\n    float textureId = floor(vTextureId+0.5);\r\n    %FOR_LOOP%\r\n\r\n    gl_FragColor = vColor * texColor * alpha;\r\n}\r\n`;\r\n\r\nexport interface IDashParams {\r\n    dash: number;\r\n    gap: number;\r\n}\r\n\r\nexport class DashLineShader extends SmoothGraphicsShader\r\n{\r\n    constructor(dashParams?: IDashParams)\r\n    {\r\n        const settings = { maxStyles: 16, maxTextures: 1, pixelLine: 1 };\r\n\r\n        super(settings, new SmoothGraphicsProgram(settings, undefined, dashFrag),\r\n            dashParams || {\r\n                dash: 5.0,\r\n                gap: 8.0\r\n            });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;IAWA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;;IAEA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;;ICzKA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;ICzCA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;;ICjGA;IACA;IACA;IACA;IACA;AACA;;IAEA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IC1EA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;;ICpBA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;ICVA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;;ICjRA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICxJA;AAQA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IC7IA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;;ICzDA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IC9IA;AACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;;ICtcA;IACA;IACA;IACA;IACA;IACA;;ICSA;IACA;IACA;IACA;AACA;AACA;;;AAGA;IACA;IACA;AACA;;IAEA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;ICl4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;;;ICjiBA;IACA;IACA;IACA;IACA;;ICaA;AACA;IACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;ICl7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}