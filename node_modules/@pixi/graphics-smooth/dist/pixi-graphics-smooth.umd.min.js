/* eslint-disable */
this.PIXI=this.PIXI||{},this.PIXI.smooth=this.PIXI.smooth||{},function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@pixi/math"),require("@pixi/core"),require("@pixi/constants"),require("@pixi/graphics"),require("@pixi/utils"),require("@pixi/display")):"function"==typeof define&&define.amd?define(["exports","@pixi/math","@pixi/core","@pixi/constants","@pixi/graphics","@pixi/utils","@pixi/display"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)._pixi_graphics_smooth={},t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI.utils,t.PIXI)}(this,(function(t,e,n,i,s,r,a){"use strict";function l(t,e,n=.001){return this===e||Math.abs(t.a-e.a)<n&&Math.abs(t.b-e.b)<n&&Math.abs(t.c-e.c)<n&&Math.abs(t.d-e.d)<n&&Math.abs(t.tx-e.tx)<n&&Math.abs(t.ty-e.ty)<n}class o{constructor(){this.textureIds=[],this.matrices=[],this.lines=[],this.count=0}clear(){for(let t=0;t<this.count;t++)this.textureIds[t]=null,this.matrices[t]=null;this.count=0}add(t,e,n,i,s,r){const{textureIds:a,matrices:o,lines:h,count:c}=this;t=4*t+s;for(let s=0;s<c;s++)if(h[2*s]===n&&h[2*s+1]===i&&a[s]===t&&l(o[s],e))return s;return c>=r.maxStyles?-1:(a[c]=t,o[c]=e,h[2*c]=n,h[2*c+1]=i,this.count++,c)}}class h{constructor(){this.texArray=new n.BatchTextureArray,this.styleArray=new o,this.shader=null,this.blend=i.BLEND_MODES.NORMAL,this.start=0,this.size=0,this.TICK=0,this.settings=null,this.data=null}clear(){this.texArray.clear(),this.styleArray.clear(),this.settings=null,this.data=null,this.shader=null}begin(t,e){this.TICK=++n.BaseTexture._globalBatch,this.settings=t,this.shader=e,this.start=0,this.size=0,this.data=null,e&&e.settings&&(this.settings=e.settings)}check(t){return 0===this.size?(this.shader=t,!0):this.shader===t}add(t,n,i,s,r){const{texArray:a,TICK:l,styleArray:o,settings:h}=this,{baseTexture:c}=t;if(c._batchEnabled!==l&&a.count===h.maxTextures)return-1;const u=c._batchEnabled!==l?a.count:c._batchLocation,p=o.add(u,n||e.Matrix.IDENTITY,i,s,r,h);return p>=0&&c._batchEnabled!==l&&(c._batchEnabled=l,c._batchLocation=a.count,a.elements[a.count++]=c),p}}class c{constructor(){this.reset()}begin(t,e,n){this.reset(),this.style=t,this.start=e,this.attribStart=n,this.jointEnd=0}end(t,e){this.attribSize=e-this.attribStart,this.size=t-this.start}reset(){this.style=null,this.size=0,this.start=0,this.attribStart=0,this.attribSize=0,this.styleId=-1,this.rgba=0,this.jointEnd=0}}class u{constructor(){this.reset()}toJSON(){return this.copyTo({})}clone(){return this.copyTo(new u)}copyTo(t){return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.shader=this.shader,t.visible=this.visible,t.smooth=this.smooth,t.matrixTex=null,t}packLineScale(){return 0}reset(){this.color=16777215,this.alpha=1,this.texture=n.Texture.WHITE,this.matrix=null,this.shader=null,this.visible=!1,this.smooth=!1,this.matrixTex=null}destroy(){this.texture=null,this.matrix=null,this.matrixTex=null}getTextureMatrix(){const t=this.texture;return this.matrix?t.frame.width===t.baseTexture.width&&t.frame.height===t.baseTexture.height?this.matrix:(this.matrixTex?this.matrixTex.copyFrom(this.matrix):this.matrixTex=this.matrix.clone(),this.matrixTex.translate(Number(t.frame.x),Number(t.frame.y)),this.matrixTex):null}}t.LINE_SCALE_MODE=void 0,function(t){t.NONE="none";t.NORMAL="normal";t.HORIZONTAL="horizontal";t.VERTICAL="vertical"}(t.LINE_SCALE_MODE||(t.LINE_SCALE_MODE={}));class p extends u{clone(){return this.copyTo(new p)}copyTo(t){return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.shader=this.shader,t.visible=this.visible,t.width=this.width,t.alignment=this.alignment,t.cap=this.cap,t.join=this.join,t.miterLimit=this.miterLimit,t.scaleMode=this.scaleMode,t}packLineScale(){switch(this.scaleMode){case t.LINE_SCALE_MODE.NORMAL:return 1;case t.LINE_SCALE_MODE.HORIZONTAL:return 2;case t.LINE_SCALE_MODE.VERTICAL:return 3;default:return 0}}reset(){super.reset(),this.smooth=!0,this.color=0,this.width=0,this.alignment=.5,this.cap=s.LINE_CAP.BUTT,this.join=s.LINE_JOIN.MITER,this.miterLimit=10,this.scaleMode=t.LINE_SCALE_MODE.NORMAL}}class d{constructor(){d.prototype.__init.call(this),d.prototype.__init2.call(this),d.prototype.__init3.call(this),d.prototype.__init4.call(this),d.prototype.__init5.call(this)}__init(){this.verts=[]}__init2(){this.joints=[]}__init3(){this.vertexSize=0}__init4(){this.indexSize=0}__init5(){this.closePointEps=1e-4}clear(){this.verts.length=0,this.joints.length=0,this.vertexSize=0,this.indexSize=0}destroy(){this.verts.length=0,this.joints.length=0}}t.JOINT_TYPE=void 0,function(t){t[t.NONE=0]="NONE";t[t.FILL=1]="FILL";t[t.JOINT_BEVEL=4]="JOINT_BEVEL";t[t.JOINT_MITER=8]="JOINT_MITER";t[t.JOINT_ROUND=12]="JOINT_ROUND";t[t.JOINT_CAP_BUTT=16]="JOINT_CAP_BUTT";t[t.JOINT_CAP_SQUARE=18]="JOINT_CAP_SQUARE";t[t.JOINT_CAP_ROUND=20]="JOINT_CAP_ROUND";t[t.FILL_EXPAND=24]="FILL_EXPAND";t[t.CAP_BUTT=32]="CAP_BUTT";t[t.CAP_SQUARE=64]="CAP_SQUARE";t[t.CAP_ROUND=96]="CAP_ROUND";t[t.CAP_BUTT2=128]="CAP_BUTT2"}(t.JOINT_TYPE||(t.JOINT_TYPE={}));class f{constructor(){f.prototype.__init.call(this),f.prototype.__init2.call(this),f.prototype.__init3.call(this)}static __initStatic(){this.vertsByJoint=[]}__init(){this.strideFloats=12}updateBufferSize(e,n,i,s){const{joints:r}=s;let a=!1,l=0,o=0;for(let i=e;i<e+n;i++){const e=-32&r[i],n=31&r[i];if(n===t.JOINT_TYPE.FILL){a=!0,l++;continue}if(n>=t.JOINT_TYPE.FILL_EXPAND){l+=3,o+=3;continue}const s=f.vertsByJoint[n]+f.vertsByJoint[e];s>=4&&(l+=s,o+=6+3*Math.max(s-6,0))}a&&(o+=i),s.vertexSize+=l,s.indexSize+=o}__init2(){this.bufferPos=0}__init3(){this.indexPos=0}beginPack(t,e,n,i,s=0,r=0){this.buildData=t,this.bufFloat=e,this.bufUint=n,this.indices=i,this.bufferPos=s,this.indexPos=r}endPack(){this.buildData=null,this.bufFloat=null,this.bufUint=null,this.indices=null}packInterleavedGeometry(e,n,i,s,r){const{bufFloat:a,bufUint:l,indices:o,buildData:h,strideFloats:c}=this,{joints:u,verts:p}=h;let d,T,y,_,x,v,E,g,m=this.bufferPos,I=this.indexPos,N=this.bufferPos/this.strideFloats,P=!1,b=0;for(let i=e;i<e+n;i++){const e=u[i],n=-32&u[i],h=31&u[i];if(h===t.JOINT_TYPE.FILL){P=!0,d=p[2*i],T=p[2*i+1],a[m]=d,a[m+1]=T,a[m+2]=d,a[m+3]=T,a[m+4]=d,a[m+5]=T,a[m+6]=d,a[m+7]=T,a[m+8]=b,a[m+9]=16*h,a[m+10]=s,l[m+11]=r,m+=c;continue}if(h>=t.JOINT_TYPE.FILL_EXPAND){x=p[2*i],v=p[2*i+1],d=p[2*i+2],T=p[2*i+3],y=p[2*i+4],_=p[2*i+5];const t=i+3;for(let n=0;n<3;n++)a[m]=x,a[m+1]=v,a[m+2]=d,a[m+3]=T,a[m+4]=y,a[m+5]=_,a[m+6]=p[2*(t+n)],a[m+7]=p[2*(t+n)+1],a[m+8]=b,a[m+9]=16*e+n,a[m+10]=s,l[m+11]=r,m+=c;o[I]=N,o[I+1]=N+1,o[I+2]=N+2,I+=3,N+=3;continue}const L=f.vertsByJoint[h]+f.vertsByJoint[n];if(0===L)continue;d=p[2*i],T=p[2*i+1],y=p[2*i+2],_=p[2*i+3],x=p[2*i-2],v=p[2*i-1];const O=Math.sqrt((y-d)*(y-d)+(_-T)*(_-T));0===f.vertsByJoint[h]&&(b-=O),(-3&h)!==t.JOINT_TYPE.JOINT_CAP_BUTT?(E=p[2*i+4],g=p[2*i+5]):(E=d,g=T);for(let t=0;t<L;t++)a[m]=x,a[m+1]=v,a[m+2]=d,a[m+3]=T,a[m+4]=y,a[m+5]=_,a[m+6]=E,a[m+7]=g,a[m+8]=b,a[m+9]=16*e+t,a[m+10]=s,l[m+11]=r,m+=c;b+=O,o[I]=N,o[I+1]=N+1,o[I+2]=N+2,o[I+3]=N,o[I+4]=N+2,o[I+5]=N+3,I+=6;for(let t=5;t+1<L;t++)o[I]=N+4,o[I+1]=N+t,o[I+2]=N+t+1,I+=3;N+=L}if(P){for(let t=0;t<i.length;t++)o[I+t]=i[t]+N;I+=i.length}this.bufferPos=m,this.indexPos=I}}f.__initStatic();const T=f.vertsByJoint;for(let t=0;t<256;t++)T.push(0);T[t.JOINT_TYPE.FILL]=1;for(let e=0;e<8;e++)T[t.JOINT_TYPE.FILL_EXPAND+e]=3;T[t.JOINT_TYPE.JOINT_BEVEL]=9,T[t.JOINT_TYPE.JOINT_BEVEL+1]=9,T[t.JOINT_TYPE.JOINT_BEVEL+2]=9,T[t.JOINT_TYPE.JOINT_BEVEL+3]=9,T[t.JOINT_TYPE.JOINT_ROUND]=9,T[t.JOINT_TYPE.JOINT_ROUND+1]=9,T[t.JOINT_TYPE.JOINT_ROUND+2]=9,T[t.JOINT_TYPE.JOINT_ROUND+3]=9,T[t.JOINT_TYPE.JOINT_MITER]=9,T[t.JOINT_TYPE.JOINT_MITER+1]=9,T[t.JOINT_TYPE.JOINT_MITER+2]=4,T[t.JOINT_TYPE.JOINT_MITER+3]=4,T[t.JOINT_TYPE.JOINT_CAP_BUTT]=4,T[t.JOINT_TYPE.JOINT_CAP_BUTT+1]=4,T[t.JOINT_TYPE.JOINT_CAP_SQUARE]=4,T[t.JOINT_TYPE.JOINT_CAP_SQUARE+1]=4,T[t.JOINT_TYPE.JOINT_CAP_ROUND]=9,T[t.JOINT_TYPE.JOINT_CAP_ROUND+1]=9,T[t.JOINT_TYPE.CAP_ROUND]=4;class y{constructor(t,e=null,n=null,i=null){this.shape=t,this.lineStyle=n,this.fillStyle=e,this.matrix=i,this.type=t.type,this.points=[],this.holes=[],this.triangles=[],this.closeStroke=!1,this.clearBuild()}clearPath(){this.points.length=0,this.closeStroke=!0}clearBuild(){this.triangles.length=0,this.fillStart=0,this.fillLen=0,this.strokeStart=0,this.strokeLen=0,this.fillAA=!1}clone(){return new y(this.shape,this.fillStyle,this.lineStyle,this.matrix)}capType(){let e;switch(this.lineStyle.cap){case s.LINE_CAP.SQUARE:e=t.JOINT_TYPE.CAP_SQUARE;break;case s.LINE_CAP.ROUND:e=t.JOINT_TYPE.CAP_ROUND;break;default:e=t.JOINT_TYPE.CAP_BUTT}return e}goodJointType(){let e;switch(this.lineStyle.join){case s.LINE_JOIN.BEVEL:e=t.JOINT_TYPE.JOINT_BEVEL;break;case s.LINE_JOIN.ROUND:e=t.JOINT_TYPE.JOINT_ROUND;break;default:e=t.JOINT_TYPE.JOINT_MITER+3}return e}jointType(){let e;switch(this.lineStyle.join){case s.LINE_JOIN.BEVEL:e=t.JOINT_TYPE.JOINT_BEVEL;break;case s.LINE_JOIN.ROUND:e=t.JOINT_TYPE.JOINT_ROUND;break;default:e=t.JOINT_TYPE.JOINT_MITER}return e}destroy(){this.shape=null,this.holes.length=0,this.holes=null,this.points.length=0,this.points=null,this.lineStyle=null,this.fillStyle=null,this.triangles=null}}class _{path(t,n){const i=t.shape,s=t.points,r=i.x,a=i.y;let l,o;if(t.type===e.SHAPES.CIRC)l=i.radius,o=i.radius;else{const e=t.shape;l=e.width,o=e.height}if(l<=0||o<=0)return;let h=Math.floor(30*Math.sqrt(i.radius))||Math.floor(15*Math.sqrt(l+o));h/=2.3,h=h<3?3:Math.ceil(h);const c=2*Math.PI/h;for(let t=0;t<h;t++)s.push(r+Math.sin(-c*t)*l,a+Math.cos(-c*t)*o)}fill(e,n){const{verts:i,joints:s}=n,{points:r,triangles:a}=e;let l=1;const o=e.shape,h=e.matrix,c=o.x,u=o.y,p=h?h.a*c+h.c*u+h.tx:c,d=h?h.b*c+h.d*u+h.ty:u;if(!e.fillAA){i.push(p,d),s.push(t.JOINT_TYPE.FILL);for(let e=0;e<r.length;e+=2)i.push(r[e],r[e+1]),s.push(t.JOINT_TYPE.FILL),e>0&&a.push(l++,0,l);return void a.push(l,0,1)}const f=o.radius;for(let e=0;e<r.length;e+=2){const n=e,a=e+2<r.length?e+2:0;i.push(p),i.push(d),i.push(r[n]),i.push(r[n+1]),i.push(r[a]),i.push(r[a+1]),i.push(0),i.push(0),i.push((r[n]-p)/f),i.push((r[n+1]-d)/f),i.push((r[a]-p)/f),i.push((r[a+1]-d)/f),s.push(t.JOINT_TYPE.FILL_EXPAND+2),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE)}}line(e,n){const{verts:i,joints:s}=n,{points:r}=e,a=e.goodJointType(),l=r.length;i.push(r[l-2],r[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=0;t<l;t+=2)i.push(r[t],r[t+1]),s.push(a);i.push(r[0],r[1]),s.push(t.JOINT_TYPE.NONE),i.push(r[2],r[3]),s.push(t.JOINT_TYPE.NONE)}}class x{path(t,e){const n=t.shape,i=n.x,s=n.y,r=n.width,a=n.height,l=t.points;l.length=0,l.push(i,s,i+r,s,i+r,s+a,i,s+a)}line(e,n){const{verts:i,joints:s}=n,{points:r}=e,a=e.goodJointType(),l=r.length;i.push(r[l-2],r[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=0;t<l;t+=2)i.push(r[t],r[t+1]),s.push(a);i.push(r[0],r[1]),s.push(t.JOINT_TYPE.NONE),i.push(r[2],r[3]),s.push(t.JOINT_TYPE.NONE)}fill(e,n){const{verts:i,joints:s}=n,{points:r,triangles:a}=e;a.length=0,i.push(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7]),s.push(t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL),a.push(0,1,2,0,2,3)}}function v(t,e,n){return t+(e-t)*n}function E(t,e,n,i,s,r,a=[],l=.001){const o=a;let h=0,c=0,u=0,p=0,d=0,f=0;for(let a=0,T=0;a<=20;++a)T=a/20,h=v(t,n,T),c=v(e,i,T),u=v(n,s,T),p=v(i,r,T),d=v(h,u,T),f=v(c,p,T),0===a&&Math.abs(d-o[o.length-2])<l&&Math.abs(f-o[o.length-1])<l||o.push(d,f);return o}class g{path(t,e){const n=t.shape,{points:i}=t,s=n.x,r=n.y,a=n.width,l=n.height,o=Math.max(0,Math.min(n.radius,Math.min(a,l)/2));if(i.length=0,o){const t=e.closePointEps;E(s,r+o,s,r,s+o,r,i,t),E(s+a-o,r,s+a,r,s+a,r+o,i,t),E(s+a,r+l-o,s+a,r+l,s+a-o,r+l,i,t),E(s+o,r+l,s,r+l,s,r+l-o,i,t),i.length>=4&&Math.abs(i[0]-i[i.length-2])<t&&Math.abs(i[1]-i[i.length-1])<t&&(i.pop(),i.pop())}else i.push(s,r,s+a,r,s+a,r+l,s,r+l)}line(e,n){const{verts:i,joints:s}=n,{points:r}=e,a=8===r.length?e.goodJointType():t.JOINT_TYPE.JOINT_MITER+3,l=r.length;i.push(r[l-2],r[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=0;t<l;t+=2)i.push(r[t],r[t+1]),s.push(a);i.push(r[0],r[1]),s.push(t.JOINT_TYPE.NONE),i.push(r[2],r[3]),s.push(t.JOINT_TYPE.NONE)}fill(e,n){const{verts:i,joints:s}=n,{points:a}=e;e.triangles=r.earcut(a,null,2);for(let e=0,n=a.length;e<n;e++)i.push(a[e],a[++e]),s.push(t.JOINT_TYPE.FILL)}}const m=[];class I{path(t,n){const i=t.shape,s=t.points=i.points.slice(),r=n.closePointEps,a=r*r;if(0===s.length)return;const l=new e.Point(s[0],s[1]),o=new e.Point(s[s.length-2],s[s.length-1]),h=t.closeStroke=i.closeStroke;let c=s.length,u=2;for(let t=2;t<c;t+=2){const e=s[t-2],n=s[t-1],i=s[t],a=s[t+1];let l=!0;Math.abs(e-i)<r&&Math.abs(n-a)<r&&(l=!1),l&&(s[u]=s[t],s[u+1]=s[t+1],u+=2)}s.length=c=u,u=2;for(let t=2;t+2<c;t+=2){let e=s[t-2],n=s[t-1];const i=s[t],r=s[t+1];let l=s[t+2],o=s[t+3];e-=i,n-=r,l-=i,o-=r;let h=!0;Math.abs(l*n-o*e)<a&&e*l+n*o<-a&&(h=!1),h&&(s[u]=s[t],s[u+1]=s[t+1],u+=2)}if(s[u]=s[c-2],s[u+1]=s[c-1],u+=2,s.length=c=u,!(c<=2)&&h){Math.abs(l.x-o.x)<r&&Math.abs(l.y-o.y)<r&&(s.pop(),s.pop())}}line(e,n){const{closeStroke:i,points:s}=e,r=n.closePointEps,a=s.length;if(a<=2)return;const{verts:l,joints:o}=n,h=e.jointType(),c=e.capType();let u,p,d=0;i?(u=s[a-2],p=s[a-1],o.push(t.JOINT_TYPE.NONE)):(u=s[2],p=s[3],c===t.JOINT_TYPE.CAP_ROUND?(l.push(s[0],s[1]),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.CAP_ROUND),d=0):(d=c,o.push(t.JOINT_TYPE.NONE))),l.push(u,p);for(let e=0;e<a;e+=2){const n=s[e],f=s[e+1];let T,y;e+2<a?(T=s[e+2],y=s[e+3]):(T=s[0],y=s[1]);const _=T-n,x=y-f;let v,E,g=h;e+2>=a?(v=s[2],E=s[3],i||(g=t.JOINT_TYPE.NONE)):e+4>=a?(v=s[0],E=s[1],i||(c===t.JOINT_TYPE.CAP_ROUND&&(g=t.JOINT_TYPE.JOINT_CAP_ROUND),c===t.JOINT_TYPE.CAP_BUTT&&(g=t.JOINT_TYPE.JOINT_CAP_BUTT),c===t.JOINT_TYPE.CAP_SQUARE&&(g=t.JOINT_TYPE.JOINT_CAP_SQUARE))):(v=s[e+4],E=s[e+5]);const m=n-u,I=f-p;if(h>=t.JOINT_TYPE.JOINT_BEVEL&&h<=t.JOINT_TYPE.JOINT_MITER){const e=v-T,n=E-y;if(g>=t.JOINT_TYPE.JOINT_BEVEL&&g<=t.JOINT_TYPE.JOINT_MITER+3){const i=e*x-n*_;if(Math.abs(i)<r)switch(-4&h){case t.JOINT_TYPE.JOINT_ROUND:g=t.JOINT_TYPE.JOINT_CAP_ROUND;break;default:g=t.JOINT_TYPE.JOINT_CAP_BUTT}}if(h===t.JOINT_TYPE.JOINT_MITER){let i=0;m*_+I*x>-r&&i++,g===t.JOINT_TYPE.JOINT_MITER&&e*_+n*x>-r&&(i+=2),g+=i}}0===d&&Math.abs(m*x-I*_)<r&&(d=t.JOINT_TYPE.CAP_BUTT2),g+=d,d=0,l.push(n,f),o.push(g),u=n,p=f}i?(l.push(s[0],s[1]),o.push(t.JOINT_TYPE.NONE),l.push(s[2],s[3]),o.push(t.JOINT_TYPE.NONE)):(l.push(s[a-4],s[a-3]),o.push(t.JOINT_TYPE.NONE))}fill(e,n){let i=e.points;const s=e.holes,a=n.closePointEps,{verts:l,joints:o}=n;if(i.length<6)return;const h=[];let c=i.length;for(let t=0;t<s.length;t++){const e=s[t];h.push(i.length/2),i=i.concat(e.points)}const u=m;u.length<i.length&&(u.length=i.length);let p=0;for(let t=0;t<=h.length;t++){let e=c/2;t>0&&(e=t<h.length?h[t]:i.length>>1),u[2*p]=e-1,u[2*(e-1)+1]=0;for(let t=p;t+1<e;t++)u[2*t+1]=t+1,u[2*t+2]=t;p=e}if(e.triangles=r.earcut(i,h,2),!e.triangles)return;if(!e.fillAA){for(let e=0;e<i.length;e+=2)l.push(i[e],i[e+1]),o.push(t.JOINT_TYPE.FILL);return}const{triangles:d}=e;c=i.length;for(let e=0;e<d.length;e+=3){let n=0;for(let t=0;t<3;t++){const i=d[e+t],s=d[e+(t+1)%3];u[2*i]!==s&&u[2*i+1]!==s||(n|=1<<t)}o.push(t.JOINT_TYPE.FILL_EXPAND+n),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE)}for(let t=0;t<c/2;t++){const e=u[2*t],n=u[2*t+1];let s=i[2*n+1]-i[2*t+1],r=-(i[2*n]-i[2*t]),l=i[2*t+1]-i[2*e+1],o=-(i[2*t]-i[2*e]);const h=Math.sqrt(s*s+r*r);s/=h,r/=h;const c=Math.sqrt(l*l+o*o);l/=c,o/=c;let p=s+l,d=r+o;const f=p*s+d*r;Math.abs(f)<a?(p=s,d=r):(p/=f,d/=f),u[2*t]=p,u[2*t+1]=d}for(let t=0;t<d.length;t+=3){const e=d[t],n=d[t+1],s=d[t+2],r=i[2*s+1]-i[2*n+1],a=-(i[2*s]-i[2*n]),o=i[2*n+1]-i[2*e+1];let h=1;r*-(i[2*n]-i[2*e])-o*a>0&&(h=2);for(let e=0;e<3;e++){const n=d[t+e*h%3];l.push(i[2*n],i[2*n+1])}for(let e=0;e<3;e++){const n=d[t+e*h%3];l.push(u[2*n],u[2*n+1])}}}}const N={[e.SHAPES.POLY]:new I,[e.SHAPES.CIRC]:new _,[e.SHAPES.ELIP]:new _,[e.SHAPES.RECT]:new x,[e.SHAPES.RREC]:new g},P=[],b=[],L=new e.Point,O=new a.Bounds;class S extends n.Geometry{static __initStatic(){this.BATCHABLE_SIZE=100}__init(){this.indicesUint16=null}get points(){return this.buildData.verts}get closePointEps(){return this.buildData.closePointEps}initAttributes(t){this._buffer=new n.Buffer(null,t,!1),this._bufferFloats=new Float32Array,this._bufferUint=new Uint32Array,this._indexBuffer=new n.Buffer(null,t,!0),this.addAttribute("aPrev",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aPoint1",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aPoint2",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aNext",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aTravel",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aVertexJoint",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aStyleId",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,i.TYPES.UNSIGNED_BYTE).addIndex(this._indexBuffer),this.strideFloats=12}constructor(){super(),S.prototype.__init.call(this),this.initAttributes(!1),this.buildData=new d,this.graphicsData=[],this.dirty=0,this.batchDirty=-1,this.cacheDirty=-1,this.clearDirty=0,this.drawCalls=[],this.batches=[],this.shapeBuildIndex=0,this.shapeBatchIndex=0,this._bounds=new a.Bounds,this.boundsDirty=-1,this.boundsPadding=0,this.batchable=!1,this.indicesUint16=null,this.packer=null,this.packSize=0,this.pack32index=null}checkInstancing(t,e){this.packer||(this.packer=new f,this.pack32index=e)}get bounds(){return this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds}invalidate(){this.boundsDirty=-1,this.dirty++,this.batchDirty++,this.shapeBuildIndex=0,this.shapeBatchIndex=0,this.packSize=0,this.buildData.clear();for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].clear(),b.push(this.drawCalls[t]);this.drawCalls.length=0;for(let t=0;t<this.batches.length;t++){const e=this.batches[t];e.reset(),P.push(e)}this.batches.length=0}clear(){return this.graphicsData.length>0&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this}drawShape(t,e=null,n=null,i=null){const s=new y(t,e,n,i);return this.graphicsData.push(s),this.dirty++,this}drawHole(t,e=null){if(!this.graphicsData.length)return null;const n=new y(t,null,null,e),i=this.graphicsData[this.graphicsData.length-1];return n.lineStyle=i.lineStyle,i.holes.push(n),this.dirty++,this}destroy(){super.destroy();for(let t=0;t<this.graphicsData.length;++t)this.graphicsData[t].destroy();this.buildData.destroy(),this.buildData=null,this.indexBuffer.destroy(),this.indexBuffer=null,this.graphicsData.length=0,this.graphicsData=null,this.drawCalls.length=0,this.drawCalls=null,this.batches.length=0,this.batches=null,this._bounds=null}containsPoint(t){const e=this.graphicsData;for(let n=0;n<e.length;++n){const i=e[n];if(i.fillStyle.visible&&(i.shape&&(i.matrix?i.matrix.applyInverse(t,L):L.copyFrom(t),i.shape.contains(L.x,L.y)))){let t=!1;if(i.holes)for(let e=0;e<i.holes.length;e++){if(i.holes[e].shape.contains(L.x,L.y)){t=!0;break}}if(!t)return!0}}return!1}updatePoints(){}updateBufferSize(){this._buffer.update(new Float32Array)}updateBuild(){const{graphicsData:t,buildData:n}=this,i=t.length;for(let s=this.shapeBuildIndex;s<i;s++){const i=t[s];i.strokeStart=0,i.strokeLen=0,i.fillStart=0,i.fillLen=0;const{fillStyle:r,lineStyle:a,holes:l}=i;if(!r.visible&&!a.visible)continue;const o=N[i.type];if(i.clearPath(),o.path(i,n),i.matrix&&this.transformPoints(i.points,i.matrix),i.clearBuild(),!(i.points.length<=2)&&(r.visible&&(i.fillAA=i.fillStyle.smooth&&!(i.lineStyle.visible&&i.lineStyle.alpha>=.99&&i.lineStyle.width>=.99),i.fillStart=n.joints.length,l.length?(this.processHoles(l),N[e.SHAPES.POLY].fill(i,n)):!i.fillAA||i.type!==e.SHAPES.RECT&&i.type!==e.SHAPES.RREC?o.fill(i,n):N[e.SHAPES.POLY].fill(i,n),i.fillLen=n.joints.length-i.fillStart),a.visible)){i.strokeStart=n.joints.length,o.line(i,n);for(let t=0;t<l.length;t++)o.line(l[t],n);i.strokeLen=n.joints.length-i.strokeStart}}this.shapeBuildIndex=i}updateBatches(t){if(!this.graphicsData.length)return void(this.batchable=!0);if(this.updateBuild(),!this.validateBatching())return;const{buildData:e,graphicsData:n}=this,s=n.length;this.cacheDirty=this.dirty;let r=null,a=null;this.batches.length>0&&(r=this.batches[this.batches.length-1],a=r.style);for(let t=this.shapeBatchIndex;t<s;t++){const s=n[t],l=s.fillStyle,o=s.lineStyle;if(s.matrix&&this.transformPoints(s.points,s.matrix),l.visible||o.visible)for(let t=0;t<2;t++){const n=0===t?l:o;if(!n.visible)continue;const h=n.texture.baseTexture,u=e.vertexSize,p=e.indexSize;h.wrapMode=i.WRAP_MODES.REPEAT,0===t?this.packer.updateBufferSize(s.fillStart,s.fillLen,s.triangles.length,e):this.packer.updateBufferSize(s.strokeStart,s.strokeLen,s.triangles.length,e);e.vertexSize!==u&&(r&&!this._compareStyles(a,n)&&(r.end(p,u),r=null),r||(r=P.pop()||new c,r.begin(n,p,u),this.batches.push(r),a=n),r.jointEnd=0===t?s.fillStart+s.fillLen:s.strokeStart+s.strokeLen)}}this.shapeBatchIndex=s,r&&r.end(e.indexSize,e.vertexSize),0!==this.batches.length?(this.batchable=this.isBatchable(),this.batchable?this.packBatches():(this.buildDrawCalls(t),this.updatePack())):this.batchable=!0}updatePack(){const{vertexSize:t,indexSize:e}=this.buildData;if(this.packSize===t)return;const{strideFloats:n,packer:i,buildData:s,batches:r}=this,a=this._buffer,l=this._indexBuffer,o=t*n;if(a.data.length!==o){const t=new ArrayBuffer(4*o);this._bufferFloats=new Float32Array(t),this._bufferUint=new Uint32Array(t),a.data=this._bufferFloats}l.data.length!==e&&(t>65535&&this.pack32index?l.data=new Uint32Array(e):l.data=new Uint16Array(e)),i.beginPack(s,this._bufferFloats,this._bufferUint,l.data);let h=0;for(let t=0;t<this.graphicsData.length;t++){const e=this.graphicsData[t];if(e.fillLen){for(;r[h].jointEnd<=e.fillStart;)h++;i.packInterleavedGeometry(e.fillStart,e.fillLen,e.triangles,r[h].styleId,r[h].rgba)}if(e.strokeLen){for(;r[h].jointEnd<=e.strokeStart;)h++;i.packInterleavedGeometry(e.strokeStart,e.strokeLen,e.triangles,r[h].styleId,r[h].rgba)}}a.update(),l.update(),this.packSize=t}_compareStyles(t,n){if(!t||!n)return!1;if(t.texture.baseTexture!==n.texture.baseTexture)return!1;if(t.color+t.alpha!==n.color+n.alpha)return!1;if(t.width!==n.width)return!1;if(t.scaleMode!==n.scaleMode)return!1;if(t.alignment!==n.alignment)return!1;return l(t.matrix||e.Matrix.IDENTITY,n.matrix||e.Matrix.IDENTITY)}validateBatching(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(let t=0,e=this.graphicsData.length;t<e;t++){const e=this.graphicsData[t],n=e.fillStyle,i=e.lineStyle;if(n&&!n.texture.baseTexture.valid)return!1;if(i&&!i.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++;const t=this.batches;for(let e=0,n=t.length;e<n;e++){const n=t[e];for(let t=0;t<n.size;t++){const e=n.start+t;this.indicesUint16[e]=this.indicesUint16[e]-n.attribStart}}}isBatchable(){return!1}buildDrawCalls(t){for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].clear(),b.push(this.drawCalls[t]);this.drawCalls.length=0;let e=b.pop()||new h;e.begin(t,null);let n=0;this.drawCalls.push(e);for(let i=0;i<this.batches.length;i++){const s=this.batches[i],a=s.style;if(0===s.attribSize)continue;let l=-1;const o=a.getTextureMatrix();e.check(a.shader)&&(l=e.add(a.texture,o,a.width,a.alignment||0,a.packLineScale())),l<0&&(e=b.pop()||new h,this.drawCalls.push(e),e.begin(t,a.shader),e.start=n,l=e.add(a.texture,o,a.width,a.alignment||0,a.packLineScale())),e.size+=s.size,n+=s.size;const{color:c,alpha:u}=a,p=(c>>16)+(65280&c)+((255&c)<<16);s.rgba=r.premultiplyTint(p,u),s.styleId=l}}processHoles(t){for(let e=0;e<t.length;e++){const n=t[e];N[n.type].path(n,this.buildData),n.matrix&&this.transformPoints(n.points,n.matrix)}}calculateBounds(){const t=this._bounds,n=O;let i=e.Matrix.IDENTITY;this._bounds.clear(),n.clear();for(let s=0;s<this.graphicsData.length;s++){const r=this.graphicsData[s],a=r.shape,l=r.type,o=r.lineStyle,h=r.matrix||e.Matrix.IDENTITY;let c=0;if(o&&o.visible){const t=o.alignment;c=o.width,l===e.SHAPES.POLY?c*=.5+Math.abs(.5-t):c*=Math.max(0,t)}if(i!==h&&(n.isEmpty()||(t.addBoundsMatrix(n,i),n.clear()),i=h),l===e.SHAPES.RECT||l===e.SHAPES.RREC){const t=a;n.addFramePad(t.x,t.y,t.x+t.width,t.y+t.height,c,c)}else if(l===e.SHAPES.CIRC){const t=a;n.addFramePad(t.x,t.y,t.x,t.y,t.radius+c,t.radius+c)}else if(l===e.SHAPES.ELIP){const t=a;n.addFramePad(t.x,t.y,t.x,t.y,t.width+c,t.height+c)}else{const e=a;t.addVerticesMatrix(i,e.points,0,e.points.length,c,c)}}n.isEmpty()||t.addBoundsMatrix(n,i),t.pad(this.boundsPadding,this.boundsPadding)}transformPoints(t,e){for(let n=0;n<t.length/2;n++){const i=t[2*n],s=t[2*n+1];t[2*n]=e.a*i+e.c*s+e.tx,t[2*n+1]=e.b*i+e.d*s+e.ty}}}S.__initStatic();const A=["\nfloat pixelLine(float x, float A, float B) {\n    return clamp(x + 0.5, 0.0, 1.0);\n}\n","\nfloat pixelLine(float x, float A, float B) {\n    float y = abs(x), s = sign(x);\n    if (y * 2.0 < A - B) {\n        return 0.5 + s * y / A;\n    }\n    y -= (A - B) * 0.5;\n    y = max(1.0 - y / B, 0.0);\n    return (1.0 + s * (1.0 - y * y)) * 0.5;\n    //return clamp(x + 0.5, 0.0, 1.0);\n}\n"];class J extends n.Program{constructor(t,e="#version 100\nprecision highp float;\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\n\nconst float FILL_EXPAND = 24.0;\n\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\nconst float MITER_LIMIT = 10.0;\n\n// === geom ===\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float aTravel;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\n\n// === style ===\nattribute float aStyleId;\nattribute vec4 aColor;\n\nvarying float vTextureId;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\n\nuniform vec2 styleLine[%MAX_STYLES%];\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\nuniform float styleTextureId[%MAX_STYLES%];\nuniform vec2 samplerSize[%MAX_TEXTURES%];\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect = (norm + norm2) / 2.0;\n    bisect /= dot(norm, bisect);\n    vec2 shift = dy * bisect;\n    if (inner > 0.5) {\n        if (len < len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis = pointB - pointA;\n    float len = length(xBasis);\n    vec2 forward = xBasis / len;\n    vec2 norm = vec2(forward.y, -forward.x);\n\n    float type = floor(aVertexJoint / 16.0);\n    float vertexNum = aVertexJoint - type * 16.0;\n    float dx = 0.0, dy = 1.0;\n\n    float capType = floor(type / 32.0);\n    type -= capType * 32.0;\n\n    int styleId = int(aStyleId + 0.5);\n    float lineWidth = styleLine[styleId].x;\n    vTextureId = floor(styleTextureId[styleId] / 4.0);\n    float scaleMode = styleTextureId[styleId] - vTextureId * 4.0;\n    float avgScale = 1.0;\n    if (scaleMode > 2.5) {\n        avgScale = length(translationMatrix * vec3(1.0, 0.0, 0.0));\n    } else if (scaleMode > 1.5) {\n        avgScale = length(translationMatrix * vec3(0.0, 1.0, 0.0));\n    } else if (scaleMode > 0.5) {\n        vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n        avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\n    }\n    lineWidth *= 0.5 * avgScale;\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\n    vTextureCoord = vec2(0.0);\n\n    vec2 pos;\n\n    if (capType == CAP_ROUND) {\n        vertexNum += 4.0;\n        type = JOINT_CAP_ROUND;\n        capType = 0.0;\n        lineAlignment = -lineAlignment;\n    }\n\n    vLine1 = vec4(0.0, 10.0, 1.0, 0.0);\n    vLine2 = vec4(0.0, 10.0, 1.0, 0.0);\n    vArc = vec4(0.0);\n    if (type == FILL) {\n        pos = pointA;\n        vType = 0.0;\n        vLine2 = vec4(-2.0, -2.0, -2.0, 0.0);\n        vec2 vTexturePixel;\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\n        // expand vertices\n        float flags = type - FILL_EXPAND;\n        float flag3 = floor(flags / 4.0);\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\n\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\n\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\n\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\n            n1 = -n1;\n            n2 = -n2;\n            n3 = -n3;\n        }\n\n        float len2 = length(aNext);\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\n\n        if (vertexNum < 0.5) {\n            pos = prev;\n\n            if (flag1 < 0.5 && flag3 < 0.5) {\n                bisect = vec2(0.0);\n            } else if (flag1 < 0.5) {\n                bisect = vec2(n1.y, -n1.x) + n1 / 8.0;\n            } else if (flag3 < 0.5) {\n                bisect = vec2(-n3.y, n3.x) + n3 / 8.0;\n            }\n        } else if (vertexNum < 1.5) {\n            pos = pointA;\n\n            if (flag1 < 0.5 && flag2 < 0.5) {\n                bisect = vec2(0.0);\n            } else if (flag1 < 0.5) {\n                bisect = vec2(-n1.y, n1.x) + n1 / 8.0;\n            } else if (flag2 < 0.5) {\n                bisect = vec2(n2.y, -n2.x) + n2 / 8.0;\n            }\n        } else {\n            pos = pointB;\n\n            if (flag2 < 0.5 && flag3 < 0.5) {\n                bisect = vec2(0.0);\n            } else if (flag2 < 0.5) {\n                bisect = vec2(-n2.y, n2.x) + n2 / 8.0;\n            } else if (flag3 < 0.5) {\n                bisect = vec2(n3.y, -n3.x) + n3 / 8.0;\n            }\n        }\n\n        if (length(bisect) > 0.0) {\n            bisect = normalize(bisect) * len2;\n        }\n\n        pos += bisect * expand;\n\n        vLine1 = vec4(16.0, 16.0, 16.0, -1.0);\n        if (flag1 > 0.5) {\n            vLine1.x = -dot(pos - prev, n1);\n        }\n        if (flag2 > 0.5) {\n            vLine1.y = -dot(pos - pointA, n2);\n        }\n        if (flag3 > 0.5) {\n            vLine1.z = -dot(pos - pointB, n3);\n        }\n        vLine1.xyz *= resolution;\n        vType = 2.0;\n    } else if (type >= BEVEL) {\n        float dy = lineWidth + expand;\n        float shift = lineWidth * lineAlignment;\n        float inner = 0.0;\n        if (vertexNum >= 1.5) {\n            dy = -dy;\n            inner = 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag = 0.0;\n        float side2 = 1.0;\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base = pointA;\n            flag = type - floor(type / 2.0) * 2.0;\n            side2 = -1.0;\n        } else {\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\n            base = pointB;\n            if (type >= MITER && type < MITER + 3.5) {\n                flag = step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 = next - base;\n        float len2 = length(xBasis2);\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D = norm.x * norm2.y - norm.y * norm2.x;\n        if (D < 0.0) {\n            inner = 1.0 - inner;\n        }\n\n        norm2 *= side2;\n\n        float collinear = step(0.0, dot(norm, norm2));\n\n        vType = 0.0;\n        float dy2 = -1000.0;\n\n        if (abs(D) < 0.01 && collinear < 0.5) {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                type = JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        vLine1 = vec4(0.0, lineWidth, max(abs(norm.x), abs(norm.y)), min(abs(norm.x), abs(norm.y)));\n        vLine2 = vec4(0.0, lineWidth, max(abs(norm2.x), abs(norm2.y)), min(abs(norm2.x), abs(norm2.y)));\n\n        if (vertexNum < 3.5) {\n            if (abs(D) < 0.01 && collinear < 0.5) {\n                pos = (shift + dy) * norm;\n            } else {\n                if (flag < 0.5 && inner < 0.5) {\n                    pos = (shift + dy) * norm;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, inner);\n                }\n            }\n            vLine2.y = -1000.0;\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back = -forward;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    pos += back * (expand + extra);\n                    dy2 = expand;\n                } else {\n                    dy2 = dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    vLine2.y = dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos += forward * (expand + extra);\n                    vLine2.y = expand;\n                    if (capType >= CAP_BUTT) {\n                        dy2 -= expand + extra;\n                    }\n                }\n            }\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n            base += shift * norm;\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            vec2 d2 = abs(dy) * forward;\n            if (vertexNum < 4.5) {\n                dy = -dy;\n                pos = dy * norm;\n            } else if (vertexNum < 5.5) {\n                pos = dy * norm;\n            } else if (vertexNum < 6.5) {\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            } else {\n                dy = -dy;\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            }\n            vLine2 = vec4(0.0, lineWidth * 2.0 + 10.0, 1.0  , 0.0); // forget about line2 with type=3\n            vArc.y = dy;\n            vArc.z = 0.0;\n            vArc.w = lineWidth;\n            vType = 3.0;\n        } else if (abs(D) < 0.01 && collinear < 0.5) {\n            pos = dy * norm;\n        } else {\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            float side = sign(dy);\n            vec2 norm3 = normalize(norm + norm2);\n\n            if (type >= MITER && type < MITER + 3.5) {\n                vec2 farVertex = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\n                if (length(farVertex) > abs(shift + dy) * MITER_LIMIT) {\n                    type = BEVEL;\n                }\n            }\n\n            if (vertexNum < 4.5) {\n                pos = doBisect(norm, len, norm2, len2, shift - dy, 1.0);\n            } else if (vertexNum < 5.5) {\n                pos = (shift + dy) * norm;\n            } else if (vertexNum > 7.5) {\n                pos = (shift + dy) * norm2;\n            } else {\n                if (type >= ROUND && type < ROUND + 1.5) {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\n                    float d2 = abs(shift + dy);\n                    if (length(pos) > abs(shift + dy) * 1.5) {\n                        if (vertexNum < 6.5) {\n                            pos.x = (shift + dy) * norm.x - d2 * norm.y;\n                            pos.y = (shift + dy) * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x = (shift + dy) * norm2.x + d2 * norm2.y;\n                            pos.y = (shift + dy) * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                } else if (type >= MITER && type < MITER + 3.5) {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0); //farVertex\n                } else if (type >= BEVEL && type < BEVEL + 1.5) {\n                    float d2 = side / resolution;\n                    if (vertexNum < 6.5) {\n                        pos = (shift + dy) * norm + d2 * norm3;\n                    } else {\n                        pos = (shift + dy) * norm2 + d2 * norm3;\n                    }\n                }\n            }\n\n            if (type >= ROUND && type < ROUND + 1.5) {\n                vArc.x = side * dot(pos, norm3);\n                vArc.y = pos.x * norm3.y - pos.y * norm3.x;\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift);\n                vArc.w = lineWidth + side * shift;\n                vType = 3.0;\n            } else if (type >= MITER && type < MITER + 3.5) {\n                vType = 1.0;\n            } else if (type >= BEVEL && type < BEVEL + 1.5) {\n                vType = 4.0;\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift) - side * dot(pos, norm3);\n            }\n\n            dy = side * (dot(pos, norm) - shift);\n            dy2 = side * (dot(pos, norm2) - shift);\n        }\n\n        pos += base;\n        vLine1.xy = vec2(dy, vLine1.y) * resolution;\n        vLine2.xy = vec2(dy2, vLine2.y) * resolution;\n        vArc = vArc * resolution;\n        vTravel = aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x));\n    }\n\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n\n    vColor = aColor * tint;\n}",n="%PRECISION%\nvarying vec4 vColor;\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\n\n%PIXEL_LINE%\n\nvoid main(void){\n    %PIXEL_COVERAGE%\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n",i={}){const{maxStyles:s,maxTextures:r,pixelLine:a}=t;super(e=e.replace(/%MAX_TEXTURES%/gi,`${r}`).replace(/%MAX_STYLES%/gi,`${s}`),n=n.replace(/%PRECISION%/gi,"#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n").replace(/%PIXEL_LINE%/gi,A[a]).replace(/%PIXEL_COVERAGE%/gi,"float alpha = 1.0;\nif (vType < 0.5) {\n    float left = pixelLine(-vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float right = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float near = vLine2.x - 0.5;\n    float far = min(vLine2.x + 0.5, 0.0);\n    float top = vLine2.y - 0.5;\n    float bottom = min(vLine2.y + 0.5, 0.0);\n    alpha = (right - left) * max(bottom - top, 0.0) * max(far - near, 0.0);\n} else if (vType < 1.5) {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    alpha = a2 * b2 - a1 * b1;\n} else if (vType < 2.5) {\n    alpha *= max(min(vLine1.x + 0.5, 1.0), 0.0);\n    alpha *= max(min(vLine1.y + 0.5, 1.0), 0.0);\n    alpha *= max(min(vLine1.z + 0.5, 1.0), 0.0);\n} else if (vType < 3.5) {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float alpha_miter = a2 * b2 - a1 * b1;\n    float alpha_plane = clamp(vArc.z - vArc.x + 0.5, 0.0, 1.0);\n    float d = length(vArc.xy);\n    float circle_hor = max(min(vArc.w, d + 0.5) - max(-vArc.w, d - 0.5), 0.0);\n    float circle_vert = min(vArc.w * 2.0, 1.0);\n    float alpha_circle = circle_hor * circle_vert;\n    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\n} else {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    alpha = a2 * b2 - a1 * b1;\n    alpha *= clamp(vArc.z + 0.5, 0.0, 1.0);\n}\n").replace(/%MAX_TEXTURES%/gi,`${r}`).replace(/%FOR_LOOP%/gi,D.generateSampleSrc(r))),this.settings=t}}class D extends n.Shader{constructor(t,e=new J(t),n={}){const{maxStyles:i,maxTextures:s}=t,r=new Int32Array(s);for(let t=0;t<s;t++)r[t]=t;super(e,Object.assign(n,{styleMatrix:new Float32Array(6*i),styleTextureId:new Float32Array(i),styleLine:new Float32Array(2*i),samplerSize:new Float32Array(2*s),uSamplers:r,tint:new Float32Array([1,1,1,1]),resolution:1,expand:1})),this.settings=t}static generateSampleSrc(t){let e="";e+="\n",e+="\n";for(let n=0;n<t;n++)n>0&&(e+="\nelse "),n<t-1&&(e+=`if(textureId < ${n}.5)`),e+="\n{",e+=`\n\ttexColor = texture2D(uSamplers[${n}], vTextureCoord);`,e+="\n}";return e+="\n",e+="\n",e}}const M={LINE_SCALE_MODE:t.LINE_SCALE_MODE.NORMAL,SHADER_MAX_STYLES:24,SHADER_MAX_TEXTURES:4,PIXEL_LINE:0},{BezierUtils:C,QuadraticUtils:w,ArcUtils:R}=s.graphicsUtils,B=new Float32Array(3),Y={};class U extends a.Container{static __initStatic(){this._TEMP_POINT=new e.Point}get geometry(){return this._geometry}constructor(t=null){super(),this._geometry=t||new S,this._geometry.refCount++,this.shader=null,this.shaderSettings={maxStyles:M.SHADER_MAX_STYLES,maxTextures:M.SHADER_MAX_TEXTURES,pixelLine:M.PIXEL_LINE},this.state=n.State.for2d(),this._fillStyle=new u,this._lineStyle=new p,this._matrix=null,this._holeMode=!1,this.currentPath=null,this.batches=[],this.batchTint=-1,this.batchDirty=-1,this.vertexData=null,this.pluginName="smooth",this._transformID=-1,this.tint=16777215,this.blendMode=i.BLEND_MODES.NORMAL}clone(){return this.finishPoly(),new U(this._geometry)}set blendMode(t){this.state.blendMode=t}get blendMode(){return this.state.blendMode}get tint(){return this._tint}set tint(t){this._tint=t}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(e=null,n=0,i=1,s=.5,r=M.LINE_SCALE_MODE){if("number"==typeof e)"boolean"==typeof r&&(r=r?t.LINE_SCALE_MODE.NONE:t.LINE_SCALE_MODE.NORMAL),e={width:e,color:n,alpha:i,alignment:s,scaleMode:r};else{const n=e.native;void 0!==n&&(e.scaleMode=n?t.LINE_SCALE_MODE.NONE:t.LINE_SCALE_MODE.NORMAL)}return this.lineTextureStyle(e)}lineTextureStyle(t){t=Object.assign({width:0,texture:n.Texture.WHITE,color:t&&t.texture?16777215:0,alpha:1,matrix:null,alignment:.5,native:!1,cap:s.LINE_CAP.BUTT,join:s.LINE_JOIN.MITER,miterLimit:10,shader:null,scaleMode:M.LINE_SCALE_MODE},t),this.currentPath&&this.startPoly();const e=t.width>0&&t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._lineStyle,{visible:e},t)):this._lineStyle.reset(),this}startPoly(){if(this.currentPath){const t=this.currentPath.points,n=this.currentPath.points.length;n>2&&(this.drawShape(this.currentPath),this.currentPath=new e.Polygon,this.currentPath.closeStroke=!1,this.currentPath.points.push(t[n-2],t[n-1]))}else this.currentPath=new e.Polygon,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(this.currentPath.points.length>2?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(t,e){return this.startPoly(),this.currentPath.points[0]=t,this.currentPath.points[1]=e,this}lineTo(t,e){this.currentPath||this.moveTo(0,0);const n=this.currentPath.points,i=n[n.length-2],s=n[n.length-1];return i===t&&s===e||n.push(t,e),this}_initCurve(t=0,e=0){this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[t,e]):this.moveTo(t,e)}quadraticCurveTo(t,e,n,i){this._initCurve();const s=this.currentPath.points;return 0===s.length&&this.moveTo(0,0),w.curveTo(t,e,n,i,s),this}bezierCurveTo(t,e,n,i,s,r){return this._initCurve(),C.curveTo(t,e,n,i,s,r,this.currentPath.points),this}arcTo(t,e,n,i,s){this._initCurve(t,e);const r=this.currentPath.points,a=R.curveTo(t,e,n,i,s,r);if(a){const{cx:t,cy:e,radius:n,startAngle:i,endAngle:s,anticlockwise:r}=a;this.arc(t,e,n,i,s,r)}return this}arc(t,n,i,s,r,a=!1){if(s===r)return this;!a&&r<=s?r+=e.PI_2:a&&s<=r&&(s+=e.PI_2);if(0===r-s)return this;const l=t+Math.cos(s)*i,o=n+Math.sin(s)*i,h=this._geometry.closePointEps;let c=this.currentPath?this.currentPath.points:null;if(c){const t=Math.abs(c[c.length-2]-l),e=Math.abs(c[c.length-1]-o);t<h&&e<h||c.push(l,o)}else this.moveTo(l,o),c=this.currentPath.points;return R.arc(l,o,t,n,i,s,r,a,c),this}beginFill(t=0,e=1,i=!1){return this.beginTextureFill({texture:n.Texture.WHITE,color:t,alpha:e,smooth:i})}beginTextureFill(t){t=Object.assign({texture:n.Texture.WHITE,color:16777215,alpha:1,matrix:null,smooth:!1},t),this.currentPath&&this.startPoly();const e=t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._fillStyle,{visible:e},t)):this._fillStyle.reset(),this}endFill(){return this.finishPoly(),this._fillStyle.reset(),this}drawRect(t,n,i,s){return this.drawShape(new e.Rectangle(t,n,i,s))}drawRoundedRect(t,n,i,s,r){return this.drawShape(new e.RoundedRectangle(t,n,i,s,r))}drawCircle(t,n,i){return this.drawShape(new e.Circle(t,n,i))}drawEllipse(t,n,i,s){return this.drawShape(new e.Ellipse(t,n,i,s))}drawPolygon(...t){let n,i=!0;const s=t[0];s.points?(i=s.closeStroke,n=s.points):n=Array.isArray(t[0])?t[0]:t;const r=new e.Polygon(n);return r.closeStroke=i,this.drawShape(r),this}drawShape(t){return this._holeMode?this._geometry.drawHole(t,this._matrix):this._geometry.drawShape(t,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this}clear(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this}isFastRect(){const t=this._geometry.graphicsData;return!(1!==t.length||t[0].shape.type!==e.SHAPES.RECT||t[0].matrix||t[0].holes.length||t[0].lineStyle.visible&&t[0].lineStyle.width)}_renderCanvas(t){s.Graphics.prototype._renderCanvas.call(this,t)}_render(t){this.finishPoly();const e=this._geometry,n=t.context.supports.uint32Indices;e.checkInstancing(t.geometry.hasInstance,n),e.updateBatches(this.shaderSettings),e.batchable?(this.batchDirty!==e.batchDirty&&this._populateBatches(),this._renderBatched(t)):(t.batch.flush(),this._renderDirect(t))}_populateBatches(){const t=this._geometry,e=this.blendMode,n=t.batches.length;this.batchTint=-1,this._transformID=-1,this.batchDirty=t.batchDirty,this.batches.length=n,this.vertexData=new Float32Array(t.points);for(let i=0;i<n;i++){const n=t.batches[i],s=n.style.color,a={vertexData:new Float32Array(this.vertexData.buffer,4*n.attribStart*2,2*n.attribSize),blendMode:e,_batchRGB:r.hex2rgb(s),_tintRGB:s,_texture:n.style.texture,alpha:n.style.alpha,worldAlpha:1};this.batches[i]=a}}_renderBatched(t){if(this.batches.length){t.batch.setObjectRenderer(t.plugins[this.pluginName]),this.calculateVertices(),this.calculateTints();for(let e=0,n=this.batches.length;e<n;e++){const n=this.batches[e];n.worldAlpha=this.worldAlpha*n.alpha,t.plugins[this.pluginName].render(n)}}}_renderDirect(t){const e=this._resolveDirectShader(t);let n=e;const s=this._geometry,r=this.tint,a=this.worldAlpha,l=n.uniforms,o=s.drawCalls;l.translationMatrix=this.transform.worldTransform,l.tint[0]=(r>>16&255)/255*a,l.tint[1]=(r>>8&255)/255*a,l.tint[2]=(255&r)/255*a,l.tint[3]=a,l.resolution=t.renderTexture.current?t.renderTexture.current.resolution:t.resolution;const h=t.projection.transform;if(h){const t=Math.sqrt(h.a*h.a+h.b*h.b);l.resolution*=t}l.expand=(t.options.antialias?2:1)/l.resolution,t.shader.bind(n),t.geometry.bind(s,n),t.state.set(this.state),n=null;for(let r=0,a=o.length;r<a;r++){const a=s.drawCalls[r],o=n!==a.shader;o&&(n=a.shader,n&&(n.uniforms.translationMatrix=this.transform.worldTransform,n.uniforms.tint&&(n.uniforms.tint[0]=l.tint[0],n.uniforms.tint[1]=l.tint[1],n.uniforms.tint[2]=l.tint[2],n.uniforms.tint[3]=l.tint[3])));const{texArray:h,styleArray:c,size:u,start:p}=a,d=h.count,f=n||e,T=f.uniforms.styleTextureId,y=f.uniforms.styleMatrix,_=f.uniforms.styleLine;for(let t=0;t<c.count;t++){T[t]=c.textureIds[t],_[2*t]=c.lines[2*t],_[2*t+1]=c.lines[2*t+1];const e=c.matrices[t];y[6*t]=e.a,y[6*t+1]=e.c,y[6*t+2]=e.tx,y[6*t+3]=e.b,y[6*t+4]=e.d,y[6*t+5]=e.ty}const x=f.uniforms.samplerSize;for(let t=0;t<d;t++)x[2*t]=h.elements[t].width,x[2*t+1]=h.elements[t].height;t.shader.bind(f),o&&t.geometry.bind(s);for(let e=0;e<d;e++)t.texture.bind(h.elements[e],e);t.geometry.draw(i.DRAW_MODES.TRIANGLES,u,p)}}_resolveDirectShader(t){let e=this.shader;const n=this.pluginName;return e||(Y[n]||(Y[n]=new D(this.shaderSettings)),e=Y[n]),e}_calculateBounds(){this.finishPoly();const t=this._geometry;if(!t.graphicsData.length)return;const{minX:e,minY:n,maxX:i,maxY:s}=t.bounds;this._bounds.addFrame(this.transform,e,n,i,s)}containsPoint(t){return this.worldTransform.applyInverse(t,U._TEMP_POINT),this._geometry.containsPoint(U._TEMP_POINT)}calculateTints(){if(this.batchTint!==this.tint){this.batchTint=this.tint;const t=r.hex2rgb(this.tint,B);for(let e=0;e<this.batches.length;e++){const n=this.batches[e],i=n._batchRGB,s=(t[0]*i[0]*255<<16)+(t[1]*i[1]*255<<8)+(0|t[2]*i[2]*255);n._tintRGB=(s>>16)+(65280&s)+((255&s)<<16)}}}calculateVertices(){const t=this.transform._worldID;if(this._transformID===t)return;this._transformID=t;const e=this.transform.worldTransform,n=e.a,i=e.b,s=e.c,r=e.d,a=e.tx,l=e.ty,o=this._geometry.points,h=this.vertexData;let c=0;for(let t=0;t<o.length;t+=2){const e=o[t],u=o[t+1];h[c++]=n*e+s*u+a,h[c++]=r*u+i*e+l}}closePath(){const t=this.currentPath;return t&&(t.closeStroke=!0),this}setMatrix(t){return this._matrix=t,this}beginHole(){return this.finishPoly(),this._holeMode=!0,this}endHole(){return this.finishPoly(),this._holeMode=!1,this}destroy(t){this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose(),this._matrix=null,this.currentPath=null,this._lineStyle.destroy(),this._lineStyle=null,this._fillStyle.destroy(),this._fillStyle=null,this._geometry=null,this.shader=null,this.vertexData=null,this.batches.length=0,this.batches=null,super.destroy(t)}}U.__initStatic();t.BATCH_POOL=P,t.BatchDrawCall=h,t.BatchPart=c,t.BatchStyleArray=o,t.BuildData=d,t.CircleBuilder=_,t.DRAW_CALL_POOL=b,t.DashLineShader=class extends D{constructor(t){const e={maxStyles:16,maxTextures:1,pixelLine:1};super(e,new J(e,void 0,"%PRECISION%\nvarying vec4 vColor;\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\nuniform float dash;\nuniform float gap;\n\n%PIXEL_LINE%\n\nvoid main(void){\n    %PIXEL_COVERAGE%\n\n    if (dash + gap > 1.0)\n    {\n        float travel = mod(vTravel + gap * 0.5, dash + gap) - (gap * 0.5);\n        float left = max(travel - 0.5, -0.5);\n        float right = min(travel + 0.5, gap + 0.5);\n        alpha *= max(0.0, right - left);\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n"),t||{dash:5,gap:8})}},t.FILL_COMMANDS=N,t.FillStyle=u,t.LineStyle=p,t.PolyBuilder=I,t.RectangleBuilder=x,t.RoundedRectangleBuilder=g,t.SegmentPacker=f,t.SmoothGraphics=U,t.SmoothGraphicsData=y,t.SmoothGraphicsGeometry=S,t.SmoothGraphicsProgram=J,t.SmoothGraphicsShader=D,t.matrixEquals=l,t.settings=M,Object.defineProperty(t,"__esModule",{value:!0})})),"undefined"!=typeof _pixi_graphics_smooth&&Object.assign(this.PIXI.smooth,_pixi_graphics_smooth);
//# sourceMappingURL=pixi-graphics-smooth.umd.min.js.map
